"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nodemailer";
exports.ids = ["vendor-chunks/nodemailer"];
exports.modules = {

/***/ "(rsc)/./node_modules/nodemailer/lib/addressparser/index.js":
/*!************************************************************!*\
  !*** ./node_modules/nodemailer/lib/addressparser/index.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @param {Number} depth Current recursion depth for nested group protection\n * @return {Object} Address object\n */\nfunction _handleAddress(tokens, depth) {\n    let isGroup = false;\n    let state = 'text';\n    let address;\n    let addresses = [];\n    let data = {\n        address: [],\n        comment: [],\n        group: [],\n        text: [],\n        textWasQuoted: [] // Track which text tokens came from inside quotes\n    };\n    let i;\n    let len;\n    let insideQuotes = false; // Track if we're currently inside a quoted string\n\n    // Filter out <addresses>, (comments) and regular text\n    for (i = 0, len = tokens.length; i < len; i++) {\n        let token = tokens[i];\n        let prevToken = i ? tokens[i - 1] : null;\n        if (token.type === 'operator') {\n            switch (token.value) {\n                case '<':\n                    state = 'address';\n                    insideQuotes = false;\n                    break;\n                case '(':\n                    state = 'comment';\n                    insideQuotes = false;\n                    break;\n                case ':':\n                    state = 'group';\n                    isGroup = true;\n                    insideQuotes = false;\n                    break;\n                case '\"':\n                    // Track quote state for text tokens\n                    insideQuotes = !insideQuotes;\n                    state = 'text';\n                    break;\n                default:\n                    state = 'text';\n                    insideQuotes = false;\n                    break;\n            }\n        } else if (token.value) {\n            if (state === 'address') {\n                // handle use case where unquoted name includes a \"<\"\n                // Apple Mail truncates everything between an unexpected < and an address\n                // and so will we\n                token.value = token.value.replace(/^[^<]*<\\s*/, '');\n            }\n\n            if (prevToken && prevToken.noBreak && data[state].length) {\n                // join values\n                data[state][data[state].length - 1] += token.value;\n                if (state === 'text' && insideQuotes) {\n                    data.textWasQuoted[data.textWasQuoted.length - 1] = true;\n                }\n            } else {\n                data[state].push(token.value);\n                if (state === 'text') {\n                    data.textWasQuoted.push(insideQuotes);\n                }\n            }\n        }\n    }\n\n    // If there is no text but a comment, replace the two\n    if (!data.text.length && data.comment.length) {\n        data.text = data.comment;\n        data.comment = [];\n    }\n\n    if (isGroup) {\n        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n        data.text = data.text.join(' ');\n\n        // Parse group members, but flatten any nested groups (RFC 5322 doesn't allow nesting)\n        let groupMembers = [];\n        if (data.group.length) {\n            let parsedGroup = addressparser(data.group.join(','), { _depth: depth + 1 });\n            // Flatten: if any member is itself a group, extract its members into the sequence\n            parsedGroup.forEach(member => {\n                if (member.group) {\n                    // Nested group detected - flatten it by adding its members directly\n                    groupMembers = groupMembers.concat(member.group);\n                } else {\n                    groupMembers.push(member);\n                }\n            });\n        }\n\n        addresses.push({\n            name: data.text || (address && address.name),\n            group: groupMembers\n        });\n    } else {\n        // If no address was found, try to detect one from regular text\n        if (!data.address.length && data.text.length) {\n            for (i = data.text.length - 1; i >= 0; i--) {\n                // Security fix: Do not extract email addresses from quoted strings\n                // RFC 5321 allows @ inside quoted local-parts like \"user@domain\"@example.com\n                // Extracting emails from quoted text leads to misrouting vulnerabilities\n                if (!data.textWasQuoted[i] && data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n                    data.address = data.text.splice(i, 1);\n                    data.textWasQuoted.splice(i, 1);\n                    break;\n                }\n            }\n\n            let _regexHandler = function (address) {\n                if (!data.address.length) {\n                    data.address = [address.trim()];\n                    return ' ';\n                } else {\n                    return address;\n                }\n            };\n\n            // still no address\n            if (!data.address.length) {\n                for (i = data.text.length - 1; i >= 0; i--) {\n                    // Security fix: Do not extract email addresses from quoted strings\n                    if (!data.textWasQuoted[i]) {\n                        // fixed the regex to parse email address correctly when email address has more than one @\n                        data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n                        if (data.address.length) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // If there's still is no text but a comment exixts, replace the two\n        if (!data.text.length && data.comment.length) {\n            data.text = data.comment;\n            data.comment = [];\n        }\n\n        // Keep only the first address occurence, push others to regular text\n        if (data.address.length > 1) {\n            data.text = data.text.concat(data.address.splice(1));\n        }\n\n        // Join values with spaces\n        data.text = data.text.join(' ');\n        data.address = data.address.join(' ');\n\n        if (!data.address && isGroup) {\n            return [];\n        } else {\n            address = {\n                address: data.address || data.text || '',\n                name: data.text || data.address || ''\n            };\n\n            if (address.address === address.name) {\n                if ((address.address || '').match(/@/)) {\n                    address.name = '';\n                } else {\n                    address.address = '';\n                }\n            }\n\n            addresses.push(address);\n        }\n    }\n\n    return addresses;\n}\n\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\nclass Tokenizer {\n    constructor(str) {\n        this.str = (str || '').toString();\n        this.operatorCurrent = '';\n        this.operatorExpecting = '';\n        this.node = null;\n        this.escaped = false;\n\n        this.list = [];\n        /**\n         * Operator tokens and which tokens are expected to end the sequence\n         */\n        this.operators = {\n            '\"': '\"',\n            '(': ')',\n            '<': '>',\n            ',': '',\n            ':': ';',\n            // Semicolons are not a legal delimiter per the RFC2822 grammar other\n            // than for terminating a group, but they are also not valid for any\n            // other use in this context.  Given that some mail clients have\n            // historically allowed the semicolon as a delimiter equivalent to the\n            // comma in their UI, it makes sense to treat them the same as a comma\n            // when used outside of a group.\n            ';': ''\n        };\n    }\n\n    /**\n     * Tokenizes the original input string\n     *\n     * @return {Array} An array of operator|text tokens\n     */\n    tokenize() {\n        let list = [];\n\n        for (let i = 0, len = this.str.length; i < len; i++) {\n            let chr = this.str.charAt(i);\n            let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;\n            this.checkChar(chr, nextChr);\n        }\n\n        this.list.forEach(node => {\n            node.value = (node.value || '').toString().trim();\n            if (node.value) {\n                list.push(node);\n            }\n        });\n\n        return list;\n    }\n\n    /**\n     * Checks if a character is an operator or text and acts accordingly\n     *\n     * @param {String} chr Character from the address field\n     */\n    checkChar(chr, nextChr) {\n        if (this.escaped) {\n            // ignore next condition blocks\n        } else if (chr === this.operatorExpecting) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n\n            if (nextChr && ![' ', '\\t', '\\r', '\\n', ',', ';'].includes(nextChr)) {\n                this.node.noBreak = true;\n            }\n\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = '';\n            this.escaped = false;\n\n            return;\n        } else if (!this.operatorExpecting && chr in this.operators) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = this.operators[chr];\n            this.escaped = false;\n            return;\n        } else if (['\"', \"'\"].includes(this.operatorExpecting) && chr === '\\\\') {\n            this.escaped = true;\n            return;\n        }\n\n        if (!this.node) {\n            this.node = {\n                type: 'text',\n                value: ''\n            };\n            this.list.push(this.node);\n        }\n\n        if (chr === '\\n') {\n            // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually\n            // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy.\n            chr = ' ';\n        }\n\n        if (chr.charCodeAt(0) >= 0x21 || [' ', '\\t'].includes(chr)) {\n            // skip command bytes\n            this.node.value += chr;\n        }\n\n        this.escaped = false;\n    }\n}\n\n/**\n * Maximum recursion depth for parsing nested groups.\n * RFC 5322 doesn't allow nested groups, so this is a safeguard against\n * malicious input that could cause stack overflow.\n */\nconst MAX_NESTED_GROUP_DEPTH = 50;\n\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @param {Object} options Optional options object\n * @param {Number} options._depth Internal recursion depth counter (do not set manually)\n * @return {Array} An array of address objects\n */\nfunction addressparser(str, options) {\n    options = options || {};\n    let depth = options._depth || 0;\n\n    // Prevent stack overflow from deeply nested groups (DoS protection)\n    if (depth > MAX_NESTED_GROUP_DEPTH) {\n        return [];\n    }\n\n    let tokenizer = new Tokenizer(str);\n    let tokens = tokenizer.tokenize();\n\n    let addresses = [];\n    let address = [];\n    let parsedAddresses = [];\n\n    tokens.forEach(token => {\n        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n            if (address.length) {\n                addresses.push(address);\n            }\n            address = [];\n        } else {\n            address.push(token);\n        }\n    });\n\n    if (address.length) {\n        addresses.push(address);\n    }\n\n    addresses.forEach(address => {\n        address = _handleAddress(address, depth);\n        if (address.length) {\n            parsedAddresses = parsedAddresses.concat(address);\n        }\n    });\n\n    if (options.flatten) {\n        let addresses = [];\n        let walkAddressList = list => {\n            list.forEach(address => {\n                if (address.group) {\n                    return walkAddressList(address.group);\n                } else {\n                    addresses.push(address);\n                }\n            });\n        };\n        walkAddressList(parsedAddresses);\n        return addresses;\n    }\n\n    return parsedAddresses;\n}\n\n// expose to the world\nmodule.exports = addressparser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvYWRkcmVzc3BhcnNlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLG1CQUFtQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0NBQXdDO0FBQ2pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2x5bWFya2V0LWFyYml0cmFnZS1ub2RlLy4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL2FkZHJlc3NwYXJzZXIvaW5kZXguanM/NjE5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydHMgdG9rZW5zIGZvciBhIHNpbmdsZSBhZGRyZXNzIGludG8gYW4gYWRkcmVzcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgVG9rZW5zIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIEN1cnJlbnQgcmVjdXJzaW9uIGRlcHRoIGZvciBuZXN0ZWQgZ3JvdXAgcHJvdGVjdGlvblxuICogQHJldHVybiB7T2JqZWN0fSBBZGRyZXNzIG9iamVjdFxuICovXG5mdW5jdGlvbiBfaGFuZGxlQWRkcmVzcyh0b2tlbnMsIGRlcHRoKSB7XG4gICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcbiAgICBsZXQgc3RhdGUgPSAndGV4dCc7XG4gICAgbGV0IGFkZHJlc3M7XG4gICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBhZGRyZXNzOiBbXSxcbiAgICAgICAgY29tbWVudDogW10sXG4gICAgICAgIGdyb3VwOiBbXSxcbiAgICAgICAgdGV4dDogW10sXG4gICAgICAgIHRleHRXYXNRdW90ZWQ6IFtdIC8vIFRyYWNrIHdoaWNoIHRleHQgdG9rZW5zIGNhbWUgZnJvbSBpbnNpZGUgcXVvdGVzXG4gICAgfTtcbiAgICBsZXQgaTtcbiAgICBsZXQgbGVuO1xuICAgIGxldCBpbnNpZGVRdW90ZXMgPSBmYWxzZTsgLy8gVHJhY2sgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIHF1b3RlZCBzdHJpbmdcblxuICAgIC8vIEZpbHRlciBvdXQgPGFkZHJlc3Nlcz4sIChjb21tZW50cykgYW5kIHJlZ3VsYXIgdGV4dFxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGxldCBwcmV2VG9rZW4gPSBpID8gdG9rZW5zW2kgLSAxXSA6IG51bGw7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2FkZHJlc3MnO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2NvbW1lbnQnO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2dyb3VwJztcbiAgICAgICAgICAgICAgICAgICAgaXNHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHF1b3RlIHN0YXRlIGZvciB0ZXh0IHRva2Vuc1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVRdW90ZXMgPSAhaW5zaWRlUXVvdGVzO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9ICd0ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAndGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdXNlIGNhc2Ugd2hlcmUgdW5xdW90ZWQgbmFtZSBpbmNsdWRlcyBhIFwiPFwiXG4gICAgICAgICAgICAgICAgLy8gQXBwbGUgTWFpbCB0cnVuY2F0ZXMgZXZlcnl0aGluZyBiZXR3ZWVuIGFuIHVuZXhwZWN0ZWQgPCBhbmQgYW4gYWRkcmVzc1xuICAgICAgICAgICAgICAgIC8vIGFuZCBzbyB3aWxsIHdlXG4gICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi52YWx1ZS5yZXBsYWNlKC9eW148XSo8XFxzKi8sICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZUb2tlbiAmJiBwcmV2VG9rZW4ubm9CcmVhayAmJiBkYXRhW3N0YXRlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBqb2luIHZhbHVlc1xuICAgICAgICAgICAgICAgIGRhdGFbc3RhdGVdW2RhdGFbc3RhdGVdLmxlbmd0aCAtIDFdICs9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3RleHQnICYmIGluc2lkZVF1b3Rlcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnRleHRXYXNRdW90ZWRbZGF0YS50ZXh0V2FzUXVvdGVkLmxlbmd0aCAtIDFdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFbc3RhdGVdLnB1c2godG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFdhc1F1b3RlZC5wdXNoKGluc2lkZVF1b3Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdGV4dCBidXQgYSBjb21tZW50LCByZXBsYWNlIHRoZSB0d29cbiAgICBpZiAoIWRhdGEudGV4dC5sZW5ndGggJiYgZGF0YS5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICBkYXRhLnRleHQgPSBkYXRhLmNvbW1lbnQ7XG4gICAgICAgIGRhdGEuY29tbWVudCA9IFtdO1xuICAgIH1cblxuICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjYXBwZW5kaXgtQS4xLjNcbiAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS50ZXh0LmpvaW4oJyAnKTtcblxuICAgICAgICAvLyBQYXJzZSBncm91cCBtZW1iZXJzLCBidXQgZmxhdHRlbiBhbnkgbmVzdGVkIGdyb3VwcyAoUkZDIDUzMjIgZG9lc24ndCBhbGxvdyBuZXN0aW5nKVxuICAgICAgICBsZXQgZ3JvdXBNZW1iZXJzID0gW107XG4gICAgICAgIGlmIChkYXRhLmdyb3VwLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZEdyb3VwID0gYWRkcmVzc3BhcnNlcihkYXRhLmdyb3VwLmpvaW4oJywnKSwgeyBfZGVwdGg6IGRlcHRoICsgMSB9KTtcbiAgICAgICAgICAgIC8vIEZsYXR0ZW46IGlmIGFueSBtZW1iZXIgaXMgaXRzZWxmIGEgZ3JvdXAsIGV4dHJhY3QgaXRzIG1lbWJlcnMgaW50byB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIHBhcnNlZEdyb3VwLmZvckVhY2gobWVtYmVyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWVtYmVyLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5lc3RlZCBncm91cCBkZXRlY3RlZCAtIGZsYXR0ZW4gaXQgYnkgYWRkaW5nIGl0cyBtZW1iZXJzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwTWVtYmVycyA9IGdyb3VwTWVtYmVycy5jb25jYXQobWVtYmVyLmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cE1lbWJlcnMucHVzaChtZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogZGF0YS50ZXh0IHx8IChhZGRyZXNzICYmIGFkZHJlc3MubmFtZSksXG4gICAgICAgICAgICBncm91cDogZ3JvdXBNZW1iZXJzXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vIGFkZHJlc3Mgd2FzIGZvdW5kLCB0cnkgdG8gZGV0ZWN0IG9uZSBmcm9tIHJlZ3VsYXIgdGV4dFxuICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5sZW5ndGggJiYgZGF0YS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChpID0gZGF0YS50ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VjdXJpdHkgZml4OiBEbyBub3QgZXh0cmFjdCBlbWFpbCBhZGRyZXNzZXMgZnJvbSBxdW90ZWQgc3RyaW5nc1xuICAgICAgICAgICAgICAgIC8vIFJGQyA1MzIxIGFsbG93cyBAIGluc2lkZSBxdW90ZWQgbG9jYWwtcGFydHMgbGlrZSBcInVzZXJAZG9tYWluXCJAZXhhbXBsZS5jb21cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0aW5nIGVtYWlscyBmcm9tIHF1b3RlZCB0ZXh0IGxlYWRzIHRvIG1pc3JvdXRpbmcgdnVsbmVyYWJpbGl0aWVzXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLnRleHRXYXNRdW90ZWRbaV0gJiYgZGF0YS50ZXh0W2ldLm1hdGNoKC9eW15AXFxzXStAW15AXFxzXSskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0gZGF0YS50ZXh0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0V2FzUXVvdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgX3JlZ2V4SGFuZGxlciA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYWRkcmVzcyA9IFthZGRyZXNzLnRyaW0oKV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnICc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc3RpbGwgbm8gYWRkcmVzc1xuICAgICAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZGF0YS50ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlY3VyaXR5IGZpeDogRG8gbm90IGV4dHJhY3QgZW1haWwgYWRkcmVzc2VzIGZyb20gcXVvdGVkIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnRleHRXYXNRdW90ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeGVkIHRoZSByZWdleCB0byBwYXJzZSBlbWFpbCBhZGRyZXNzIGNvcnJlY3RseSB3aGVuIGVtYWlsIGFkZHJlc3MgaGFzIG1vcmUgdGhhbiBvbmUgQFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0W2ldID0gZGF0YS50ZXh0W2ldLnJlcGxhY2UoL1xccypcXGJbXkBcXHNdK0BbXlxcc10rXFxiXFxzKi8sIF9yZWdleEhhbmRsZXIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIGlzIG5vIHRleHQgYnV0IGEgY29tbWVudCBleGl4dHMsIHJlcGxhY2UgdGhlIHR3b1xuICAgICAgICBpZiAoIWRhdGEudGV4dC5sZW5ndGggJiYgZGF0YS5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS5jb21tZW50O1xuICAgICAgICAgICAgZGF0YS5jb21tZW50ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIG9ubHkgdGhlIGZpcnN0IGFkZHJlc3Mgb2NjdXJlbmNlLCBwdXNoIG90aGVycyB0byByZWd1bGFyIHRleHRcbiAgICAgICAgaWYgKGRhdGEuYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBkYXRhLnRleHQgPSBkYXRhLnRleHQuY29uY2F0KGRhdGEuYWRkcmVzcy5zcGxpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSm9pbiB2YWx1ZXMgd2l0aCBzcGFjZXNcbiAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS50ZXh0LmpvaW4oJyAnKTtcbiAgICAgICAgZGF0YS5hZGRyZXNzID0gZGF0YS5hZGRyZXNzLmpvaW4oJyAnKTtcblxuICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcyAmJiBpc0dyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGRhdGEuYWRkcmVzcyB8fCBkYXRhLnRleHQgfHwgJycsXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YS50ZXh0IHx8IGRhdGEuYWRkcmVzcyB8fCAnJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGFkZHJlc3MuYWRkcmVzcyA9PT0gYWRkcmVzcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKChhZGRyZXNzLmFkZHJlc3MgfHwgJycpLm1hdGNoKC9ALykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5uYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5hZGRyZXNzID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhZGRyZXNzZXM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRva2VuaXplciBvYmplY3QgZm9yIHRva2VuaXppbmcgYWRkcmVzcyBmaWVsZCBzdHJpbmdzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIEFkZHJlc3MgZmllbGQgc3RyaW5nXG4gKi9cbmNsYXNzIFRva2VuaXplciB7XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMuc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5vcGVyYXRvckN1cnJlbnQgPSAnJztcbiAgICAgICAgdGhpcy5vcGVyYXRvckV4cGVjdGluZyA9ICcnO1xuICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmxpc3QgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZXJhdG9yIHRva2VucyBhbmQgd2hpY2ggdG9rZW5zIGFyZSBleHBlY3RlZCB0byBlbmQgdGhlIHNlcXVlbmNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZXJhdG9ycyA9IHtcbiAgICAgICAgICAgICdcIic6ICdcIicsXG4gICAgICAgICAgICAnKCc6ICcpJyxcbiAgICAgICAgICAgICc8JzogJz4nLFxuICAgICAgICAgICAgJywnOiAnJyxcbiAgICAgICAgICAgICc6JzogJzsnLFxuICAgICAgICAgICAgLy8gU2VtaWNvbG9ucyBhcmUgbm90IGEgbGVnYWwgZGVsaW1pdGVyIHBlciB0aGUgUkZDMjgyMiBncmFtbWFyIG90aGVyXG4gICAgICAgICAgICAvLyB0aGFuIGZvciB0ZXJtaW5hdGluZyBhIGdyb3VwLCBidXQgdGhleSBhcmUgYWxzbyBub3QgdmFsaWQgZm9yIGFueVxuICAgICAgICAgICAgLy8gb3RoZXIgdXNlIGluIHRoaXMgY29udGV4dC4gIEdpdmVuIHRoYXQgc29tZSBtYWlsIGNsaWVudHMgaGF2ZVxuICAgICAgICAgICAgLy8gaGlzdG9yaWNhbGx5IGFsbG93ZWQgdGhlIHNlbWljb2xvbiBhcyBhIGRlbGltaXRlciBlcXVpdmFsZW50IHRvIHRoZVxuICAgICAgICAgICAgLy8gY29tbWEgaW4gdGhlaXIgVUksIGl0IG1ha2VzIHNlbnNlIHRvIHRyZWF0IHRoZW0gdGhlIHNhbWUgYXMgYSBjb21tYVxuICAgICAgICAgICAgLy8gd2hlbiB1c2VkIG91dHNpZGUgb2YgYSBncm91cC5cbiAgICAgICAgICAgICc7JzogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZXMgdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG9wZXJhdG9yfHRleHQgdG9rZW5zXG4gICAgICovXG4gICAgdG9rZW5pemUoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hyID0gdGhpcy5zdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgbGV0IG5leHRDaHIgPSBpIDwgbGVuIC0gMSA/IHRoaXMuc3RyLmNoYXJBdChpICsgMSkgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5jaGVja0NoYXIoY2hyLCBuZXh0Q2hyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGlzdC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IChub2RlLnZhbHVlIHx8ICcnKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjaGFyYWN0ZXIgaXMgYW4gb3BlcmF0b3Igb3IgdGV4dCBhbmQgYWN0cyBhY2NvcmRpbmdseVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNociBDaGFyYWN0ZXIgZnJvbSB0aGUgYWRkcmVzcyBmaWVsZFxuICAgICAqL1xuICAgIGNoZWNrQ2hhcihjaHIsIG5leHRDaHIpIHtcbiAgICAgICAgaWYgKHRoaXMuZXNjYXBlZCkge1xuICAgICAgICAgICAgLy8gaWdub3JlIG5leHQgY29uZGl0aW9uIGJsb2Nrc1xuICAgICAgICB9IGVsc2UgaWYgKGNociA9PT0gdGhpcy5vcGVyYXRvckV4cGVjdGluZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoclxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG5leHRDaHIgJiYgIVsnICcsICdcXHQnLCAnXFxyJywgJ1xcbicsICcsJywgJzsnXS5pbmNsdWRlcyhuZXh0Q2hyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5ub0JyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5saXN0LnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yRXhwZWN0aW5nID0gJyc7XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wZXJhdG9yRXhwZWN0aW5nICYmIGNociBpbiB0aGlzLm9wZXJhdG9ycykge1xuICAgICAgICAgICAgdGhpcy5ub2RlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5wdXNoKHRoaXMubm9kZSk7XG4gICAgICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvckV4cGVjdGluZyA9IHRoaXMub3BlcmF0b3JzW2Nocl07XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChbJ1wiJywgXCInXCJdLmluY2x1ZGVzKHRoaXMub3BlcmF0b3JFeHBlY3RpbmcpICYmIGNociA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5saXN0LnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IG5ld2xpbmVzIHRvIHNwYWNlcy4gQ2FycmlhZ2UgcmV0dXJuIGlzIGlnbm9yZWQgYXMgXFxyIGFuZCBcXG4gdXN1YWxseVxuICAgICAgICAgICAgLy8gZ28gdG9nZXRoZXIgYW55d2F5IGFuZCB0aGVyZSBhbHJlYWR5IGlzIGEgV1MgZm9yIFxcbi4gTG9uZSBcXHIgbWVhbnMgc29tZXRoaW5nIGlzIGZpc2h5LlxuICAgICAgICAgICAgY2hyID0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoci5jaGFyQ29kZUF0KDApID49IDB4MjEgfHwgWycgJywgJ1xcdCddLmluY2x1ZGVzKGNocikpIHtcbiAgICAgICAgICAgIC8vIHNraXAgY29tbWFuZCBieXRlc1xuICAgICAgICAgICAgdGhpcy5ub2RlLnZhbHVlICs9IGNocjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXNjYXBlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBNYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aCBmb3IgcGFyc2luZyBuZXN0ZWQgZ3JvdXBzLlxuICogUkZDIDUzMjIgZG9lc24ndCBhbGxvdyBuZXN0ZWQgZ3JvdXBzLCBzbyB0aGlzIGlzIGEgc2FmZWd1YXJkIGFnYWluc3RcbiAqIG1hbGljaW91cyBpbnB1dCB0aGF0IGNvdWxkIGNhdXNlIHN0YWNrIG92ZXJmbG93LlxuICovXG5jb25zdCBNQVhfTkVTVEVEX0dST1VQX0RFUFRIID0gNTA7XG5cbi8qKlxuICogUGFyc2VzIHN0cnVjdHVyZWQgZS1tYWlsIGFkZHJlc3NlcyBmcm9tIGFuIGFkZHJlc3MgZmllbGRcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICdOYW1lIDxhZGRyZXNzQGRvbWFpbj4nXG4gKlxuICogd2lsbCBiZSBjb252ZXJ0ZWQgdG9cbiAqXG4gKiAgICAgW3tuYW1lOiAnTmFtZScsIGFkZHJlc3M6ICdhZGRyZXNzQGRvbWFpbid9XVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQWRkcmVzcyBmaWVsZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLl9kZXB0aCBJbnRlcm5hbCByZWN1cnNpb24gZGVwdGggY291bnRlciAoZG8gbm90IHNldCBtYW51YWxseSlcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBhZGRyZXNzIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gYWRkcmVzc3BhcnNlcihzdHIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgZGVwdGggPSBvcHRpb25zLl9kZXB0aCB8fCAwO1xuXG4gICAgLy8gUHJldmVudCBzdGFjayBvdmVyZmxvdyBmcm9tIGRlZXBseSBuZXN0ZWQgZ3JvdXBzIChEb1MgcHJvdGVjdGlvbilcbiAgICBpZiAoZGVwdGggPiBNQVhfTkVTVEVEX0dST1VQX0RFUFRIKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihzdHIpO1xuICAgIGxldCB0b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoKTtcblxuICAgIGxldCBhZGRyZXNzZXMgPSBbXTtcbiAgICBsZXQgYWRkcmVzcyA9IFtdO1xuICAgIGxldCBwYXJzZWRBZGRyZXNzZXMgPSBbXTtcblxuICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgKHRva2VuLnZhbHVlID09PSAnLCcgfHwgdG9rZW4udmFsdWUgPT09ICc7JykpIHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkcmVzcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgIH1cblxuICAgIGFkZHJlc3Nlcy5mb3JFYWNoKGFkZHJlc3MgPT4ge1xuICAgICAgICBhZGRyZXNzID0gX2hhbmRsZUFkZHJlc3MoYWRkcmVzcywgZGVwdGgpO1xuICAgICAgICBpZiAoYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnNlZEFkZHJlc3NlcyA9IHBhcnNlZEFkZHJlc3Nlcy5jb25jYXQoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBsZXQgd2Fsa0FkZHJlc3NMaXN0ID0gbGlzdCA9PiB7XG4gICAgICAgICAgICBsaXN0LmZvckVhY2goYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtBZGRyZXNzTGlzdChhZGRyZXNzLmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgd2Fsa0FkZHJlc3NMaXN0KHBhcnNlZEFkZHJlc3Nlcyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZEFkZHJlc3Nlcztcbn1cblxuLy8gZXhwb3NlIHRvIHRoZSB3b3JsZFxubW9kdWxlLmV4cG9ydHMgPSBhZGRyZXNzcGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/addressparser/index.js\n");

/***/ })

};
;