"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zone-eu";
exports.ids = ["vendor-chunks/@zone-eu"];
exports.modules = {

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MessageSplitter = __webpack_require__(/*! ./lib/message-splitter */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-splitter.js\");\nconst MessageJoiner = __webpack_require__(/*! ./lib/message-joiner */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-joiner.js\");\nconst NodeRewriter = __webpack_require__(/*! ./lib/node-rewriter */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-rewriter.js\");\nconst NodeStreamer = __webpack_require__(/*! ./lib/node-streamer */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-streamer.js\");\nconst Headers = __webpack_require__(/*! ./lib/headers */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/headers.js\");\nconst ChunkedPassthrough = __webpack_require__(/*! ./lib/chunked-passthrough */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js\");\n\nmodule.exports = {\n    Splitter: MessageSplitter,\n    Joiner: MessageJoiner,\n    Rewriter: NodeRewriter,\n    Streamer: NodeStreamer,\n    ChunkedPassthrough,\n    Headers\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHdCQUF3QixtQkFBTyxDQUFDLCtGQUF3QjtBQUN4RCxzQkFBc0IsbUJBQU8sQ0FBQywyRkFBc0I7QUFDcEQscUJBQXFCLG1CQUFPLENBQUMseUZBQXFCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLHlGQUFxQjtBQUNsRCxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBZTtBQUN2QywyQkFBMkIsbUJBQU8sQ0FBQyxxR0FBMkI7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2x5bWFya2V0LWFyYml0cmFnZS1ub2RlLy4vbm9kZV9tb2R1bGVzL0B6b25lLWV1L21haWxzcGxpdC9pbmRleC5qcz81MWNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWVzc2FnZVNwbGl0dGVyID0gcmVxdWlyZSgnLi9saWIvbWVzc2FnZS1zcGxpdHRlcicpO1xuY29uc3QgTWVzc2FnZUpvaW5lciA9IHJlcXVpcmUoJy4vbGliL21lc3NhZ2Utam9pbmVyJyk7XG5jb25zdCBOb2RlUmV3cml0ZXIgPSByZXF1aXJlKCcuL2xpYi9ub2RlLXJld3JpdGVyJyk7XG5jb25zdCBOb2RlU3RyZWFtZXIgPSByZXF1aXJlKCcuL2xpYi9ub2RlLXN0cmVhbWVyJyk7XG5jb25zdCBIZWFkZXJzID0gcmVxdWlyZSgnLi9saWIvaGVhZGVycycpO1xuY29uc3QgQ2h1bmtlZFBhc3N0aHJvdWdoID0gcmVxdWlyZSgnLi9saWIvY2h1bmtlZC1wYXNzdGhyb3VnaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBTcGxpdHRlcjogTWVzc2FnZVNwbGl0dGVyLFxuICAgIEpvaW5lcjogTWVzc2FnZUpvaW5lcixcbiAgICBSZXdyaXRlcjogTm9kZVJld3JpdGVyLFxuICAgIFN0cmVhbWVyOiBOb2RlU3RyZWFtZXIsXG4gICAgQ2h1bmtlZFBhc3N0aHJvdWdoLFxuICAgIEhlYWRlcnNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Transform } = __webpack_require__(/*! stream */ \"stream\");\n\nclass ChunkedPassthrough extends Transform {\n    constructor(options = {}) {\n        let config = {\n            readableObjectMode: true,\n            writableObjectMode: false\n        };\n        super(config);\n        this.chunkSize = options.chunkSize || 64 * 1024; // 64KB default\n        this.buffer = Buffer.alloc(0);\n    }\n\n    _transform(chunk, encoding, callback) {\n        this.buffer = Buffer.concat([this.buffer, chunk]);\n\n        if (this.buffer.length >= this.chunkSize) {\n            this.push(this.buffer);\n            this.buffer = Buffer.alloc(0);\n        }\n\n        callback();\n    }\n\n    _flush(callback) {\n        // Send remaining data\n        if (this.buffer.length > 0) {\n            this.push(this.buffer);\n            this.buffer = Buffer.alloc(0);\n        }\n        callback();\n    }\n}\n\nmodule.exports = ChunkedPassthrough;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9jaHVua2VkLXBhc3N0aHJvdWdoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRXRDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9seW1hcmtldC1hcmJpdHJhZ2Utbm9kZS8uL25vZGVfbW9kdWxlcy9Aem9uZS1ldS9tYWlsc3BsaXQvbGliL2NodW5rZWQtcGFzc3Rocm91Z2guanM/MmJkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY2xhc3MgQ2h1bmtlZFBhc3N0aHJvdWdoIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSBvcHRpb25zLmNodW5rU2l6ZSB8fCA2NCAqIDEwMjQ7IC8vIDY0S0IgZGVmYXVsdFxuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZmZlciwgY2h1bmtdKTtcblxuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID49IHRoaXMuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIF9mbHVzaChjYWxsYmFjaykge1xuICAgICAgICAvLyBTZW5kIHJlbWFpbmluZyBkYXRhXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2h1bmtlZFBhc3N0aHJvdWdoO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js":
/*!***************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// Helper class to rewrite nodes with specific mime type\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst libmime = __webpack_require__(/*! libmime */ \"(rsc)/./node_modules/libmime/lib/libmime.js\");\n\n/**\n * Really bad \"stream\" transform to parse format=flowed content\n *\n * @constructor\n * @param {String} delSp True if delsp option was used\n */\nclass FlowedDecoder extends Transform {\n    constructor(config) {\n        super();\n        this.config = config || {};\n\n        this.chunks = [];\n        this.chunklen = 0;\n\n        this.libmime = new libmime.Libmime({ Iconv: config.Iconv });\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (!encoding !== 'buffer') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        this.chunks.push(chunk);\n        this.chunklen += chunk.length;\n\n        callback();\n    }\n\n    _flush(callback) {\n        if (this.chunklen) {\n            let currentBody = Buffer.concat(this.chunks, this.chunklen);\n\n            if (this.config.encoding === 'base64') {\n                currentBody = Buffer.from(currentBody.toString('binary'), 'base64');\n            }\n\n            let content = this.libmime.decodeFlowed(currentBody.toString('binary'), this.config.delSp);\n            this.push(Buffer.from(content, 'binary'));\n        }\n        return callback();\n    }\n}\n\nmodule.exports = FlowedDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9mbG93ZWQtZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxrQkFBa0IsdURBQTJCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLHFCQUFxQjtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9seW1hcmtldC1hcmJpdHJhZ2Utbm9kZS8uL25vZGVfbW9kdWxlcy9Aem9uZS1ldS9tYWlsc3BsaXQvbGliL2Zsb3dlZC1kZWNvZGVyLmpzP2NjMjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBIZWxwZXIgY2xhc3MgdG8gcmV3cml0ZSBub2RlcyB3aXRoIHNwZWNpZmljIG1pbWUgdHlwZVxuXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG5jb25zdCBsaWJtaW1lID0gcmVxdWlyZSgnbGlibWltZScpO1xuXG4vKipcbiAqIFJlYWxseSBiYWQgXCJzdHJlYW1cIiB0cmFuc2Zvcm0gdG8gcGFyc2UgZm9ybWF0PWZsb3dlZCBjb250ZW50XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVsU3AgVHJ1ZSBpZiBkZWxzcCBvcHRpb24gd2FzIHVzZWRcbiAqL1xuY2xhc3MgRmxvd2VkRGVjb2RlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtsZW4gPSAwO1xuXG4gICAgICAgIHRoaXMubGlibWltZSA9IG5ldyBsaWJtaW1lLkxpYm1pbWUoeyBJY29udjogY29uZmlnLkljb252IH0pO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlbmNvZGluZyAhPT0gJ2J1ZmZlcicpIHtcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB0aGlzLmNodW5rbGVuICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIF9mbHVzaChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jaHVua2xlbikge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCb2R5ID0gQnVmZmVyLmNvbmNhdCh0aGlzLmNodW5rcywgdGhpcy5jaHVua2xlbik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qm9keSA9IEJ1ZmZlci5mcm9tKGN1cnJlbnRCb2R5LnRvU3RyaW5nKCdiaW5hcnknKSwgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMubGlibWltZS5kZWNvZGVGbG93ZWQoY3VycmVudEJvZHkudG9TdHJpbmcoJ2JpbmFyeScpLCB0aGlzLmNvbmZpZy5kZWxTcCk7XG4gICAgICAgICAgICB0aGlzLnB1c2goQnVmZmVyLmZyb20oY29udGVudCwgJ2JpbmFyeScpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmxvd2VkRGVjb2RlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/headers.js":
/*!********************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/headers.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst libmime = __webpack_require__(/*! libmime */ \"(rsc)/./node_modules/libmime/lib/libmime.js\");\n\n/**\n * Class Headers to parse and handle message headers. Headers instance allows to\n * check existing, delete or add new headers\n */\nclass Headers {\n    constructor(headers, config) {\n        config = config || {};\n\n        if (Array.isArray(headers)) {\n            // already using parsed headers\n            this.changed = true;\n            this.headers = false;\n            this.parsed = true;\n            this.lines = headers;\n        } else {\n            // using original string/buffer headers\n            this.changed = false;\n            this.headers = headers;\n            this.parsed = false;\n            this.lines = false;\n        }\n        this.mbox = false;\n        this.http = false;\n\n        this.libmime = new libmime.Libmime({ Iconv: config.Iconv });\n    }\n\n    hasHeader(key) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        key = this._normalizeHeader(key);\n        return typeof this.lines.find(line => line.key === key) === 'object';\n    }\n\n    get(key) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        key = this._normalizeHeader(key);\n        let lines = this.lines.filter(line => line.key === key).map(line => line.line);\n\n        return lines;\n    }\n\n    getDecoded(key) {\n        return this.get(key)\n            .map(line => this.libmime.decodeHeader(line))\n            .filter(line => line && line.value);\n    }\n\n    getFirst(key) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        key = this._normalizeHeader(key);\n        let header = this.lines.find(line => line.key === key);\n        if (!header) {\n            return '';\n        }\n        return ((this.libmime.decodeHeader(header.line) || {}).value || '').toString().trim();\n    }\n\n    getList() {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        return this.lines;\n    }\n\n    add(key, value, index) {\n        if (typeof value === 'undefined') {\n            return;\n        }\n\n        if (typeof value === 'number') {\n            value = value.toString();\n        }\n\n        if (typeof value === 'string') {\n            value = Buffer.from(value);\n        }\n\n        value = value.toString('binary');\n        this.addFormatted(key, this.libmime.foldLines(key + ': ' + value.replace(/\\r?\\n/g, ''), 76, false), index);\n    }\n\n    addFormatted(key, line, index) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        index = index || 0;\n        this.changed = true;\n\n        if (!line) {\n            return;\n        }\n\n        if (typeof line !== 'string') {\n            line = line.toString('binary');\n        }\n\n        let header = {\n            key: this._normalizeHeader(key),\n            line\n        };\n\n        if (index < 1) {\n            this.lines.unshift(header);\n        } else if (index >= this.lines.length) {\n            this.lines.push(header);\n        } else {\n            this.lines.splice(index, 0, header);\n        }\n    }\n\n    remove(key) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        key = this._normalizeHeader(key);\n        for (let i = this.lines.length - 1; i >= 0; i--) {\n            if (this.lines[i].key === key) {\n                this.changed = true;\n                this.lines.splice(i, 1);\n            }\n        }\n    }\n\n    update(key, value, relativeIndex) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        let keyName = key;\n        let index = 0;\n        key = this._normalizeHeader(key);\n        let relativeIndexCount = 0;\n        let relativeMatchFound = false;\n        for (let i = this.lines.length - 1; i >= 0; i--) {\n            if (this.lines[i].key === key) {\n                if (relativeIndex && relativeIndex !== relativeIndexCount) {\n                    relativeIndexCount++;\n                    continue;\n                }\n                index = i;\n                this.changed = true;\n                this.lines.splice(i, 1);\n                if (relativeIndex) {\n                    relativeMatchFound = true;\n                    break;\n                }\n            }\n        }\n\n        if (relativeIndex && !relativeMatchFound) {\n            return;\n        }\n\n        this.add(keyName, value, index);\n    }\n\n    build(lineEnd) {\n        if (!this.changed && !lineEnd) {\n            return typeof this.headers === 'string' ? Buffer.from(this.headers, 'binary') : this.headers;\n        }\n\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n\n        lineEnd = lineEnd || '\\r\\n';\n\n        let headers = this.lines.map(line => line.line.replace(/\\r?\\n/g, lineEnd)).join(lineEnd) + `${lineEnd}${lineEnd}`;\n\n        if (this.mbox) {\n            headers = this.mbox + lineEnd + headers;\n        }\n\n        if (this.http) {\n            headers = this.http + lineEnd + headers;\n        }\n\n        return Buffer.from(headers, 'binary');\n    }\n\n    _normalizeHeader(key) {\n        return (key || '').toLowerCase().trim();\n    }\n\n    _parseHeaders() {\n        if (!this.headers) {\n            this.lines = [];\n            this.parsed = true;\n            return;\n        }\n\n        let lines = this.headers\n            .toString('binary')\n            .replace(/[\\r\\n]+$/, '')\n            .split(/\\r?\\n/);\n\n        for (let i = lines.length - 1; i >= 0; i--) {\n            let chr = lines[i].charAt(0);\n            if (i && (chr === ' ' || chr === '\\t')) {\n                lines[i - 1] += '\\r\\n' + lines[i];\n                lines.splice(i, 1);\n            } else {\n                let line = lines[i];\n                if (!i && /^From /i.test(line)) {\n                    // mbox file\n                    this.mbox = line;\n                    lines.splice(i, 1);\n                    continue;\n                } else if (!i && /^POST /i.test(line)) {\n                    // HTTP POST request\n                    this.http = line;\n                    lines.splice(i, 1);\n                    continue;\n                }\n                let key = this._normalizeHeader(line.substr(0, line.indexOf(':')));\n                lines[i] = {\n                    key,\n                    line\n                };\n            }\n        }\n\n        this.lines = lines;\n        this.parsed = true;\n    }\n}\n\n// expose to the world\nmodule.exports = Headers;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9oZWFkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMscUJBQXFCO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNHQUFzRyxRQUFRLEVBQUUsUUFBUTs7QUFFeEg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9seW1hcmtldC1hcmJpdHJhZ2Utbm9kZS8uL25vZGVfbW9kdWxlcy9Aem9uZS1ldS9tYWlsc3BsaXQvbGliL2hlYWRlcnMuanM/Nzk3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGxpYm1pbWUgPSByZXF1aXJlKCdsaWJtaW1lJyk7XG5cbi8qKlxuICogQ2xhc3MgSGVhZGVycyB0byBwYXJzZSBhbmQgaGFuZGxlIG1lc3NhZ2UgaGVhZGVycy4gSGVhZGVycyBpbnN0YW5jZSBhbGxvd3MgdG9cbiAqIGNoZWNrIGV4aXN0aW5nLCBkZWxldGUgb3IgYWRkIG5ldyBoZWFkZXJzXG4gKi9cbmNsYXNzIEhlYWRlcnMge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcnMsIGNvbmZpZykge1xuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgdXNpbmcgcGFyc2VkIGhlYWRlcnNcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubGluZXMgPSBoZWFkZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNpbmcgb3JpZ2luYWwgc3RyaW5nL2J1ZmZlciBoZWFkZXJzXG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5saW5lcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWJveCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmh0dHAgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmxpYm1pbWUgPSBuZXcgbGlibWltZS5MaWJtaW1lKHsgSWNvbnY6IGNvbmZpZy5JY29udiB9KTtcbiAgICB9XG5cbiAgICBoYXNIZWFkZXIoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IHRoaXMuX25vcm1hbGl6ZUhlYWRlcihrZXkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMubGluZXMuZmluZChsaW5lID0+IGxpbmUua2V5ID09PSBrZXkpID09PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IHRoaXMuX25vcm1hbGl6ZUhlYWRlcihrZXkpO1xuICAgICAgICBsZXQgbGluZXMgPSB0aGlzLmxpbmVzLmZpbHRlcihsaW5lID0+IGxpbmUua2V5ID09PSBrZXkpLm1hcChsaW5lID0+IGxpbmUubGluZSk7XG5cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cblxuICAgIGdldERlY29kZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpXG4gICAgICAgICAgICAubWFwKGxpbmUgPT4gdGhpcy5saWJtaW1lLmRlY29kZUhlYWRlcihsaW5lKSlcbiAgICAgICAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lICYmIGxpbmUudmFsdWUpO1xuICAgIH1cblxuICAgIGdldEZpcnN0KGtleSkge1xuICAgICAgICBpZiAoIXRoaXMucGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSB0aGlzLl9ub3JtYWxpemVIZWFkZXIoa2V5KTtcbiAgICAgICAgbGV0IGhlYWRlciA9IHRoaXMubGluZXMuZmluZChsaW5lID0+IGxpbmUua2V5ID09PSBrZXkpO1xuICAgICAgICBpZiAoIWhlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKHRoaXMubGlibWltZS5kZWNvZGVIZWFkZXIoaGVhZGVyLmxpbmUpIHx8IHt9KS52YWx1ZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG4gICAgfVxuXG4gICAgZ2V0TGlzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXM7XG4gICAgfVxuXG4gICAgYWRkKGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICAgIHRoaXMuYWRkRm9ybWF0dGVkKGtleSwgdGhpcy5saWJtaW1lLmZvbGRMaW5lcyhrZXkgKyAnOiAnICsgdmFsdWUucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyksIDc2LCBmYWxzZSksIGluZGV4KTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXR0ZWQoa2V5LCBsaW5lLCBpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGxpbmUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaGVhZGVyID0ge1xuICAgICAgICAgICAga2V5OiB0aGlzLl9ub3JtYWxpemVIZWFkZXIoa2V5KSxcbiAgICAgICAgICAgIGxpbmVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW5kZXggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLnVuc2hpZnQoaGVhZGVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+PSB0aGlzLmxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5wdXNoKGhlYWRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLnNwbGljZShpbmRleCwgMCwgaGVhZGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gdGhpcy5fbm9ybWFsaXplSGVhZGVyKGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lc1tpXS5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUoa2V5LCB2YWx1ZSwgcmVsYXRpdmVJbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQga2V5TmFtZSA9IGtleTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAga2V5ID0gdGhpcy5fbm9ybWFsaXplSGVhZGVyKGtleSk7XG4gICAgICAgIGxldCByZWxhdGl2ZUluZGV4Q291bnQgPSAwO1xuICAgICAgICBsZXQgcmVsYXRpdmVNYXRjaEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lc1tpXS5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZUluZGV4ICYmIHJlbGF0aXZlSW5kZXggIT09IHJlbGF0aXZlSW5kZXhDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZUluZGV4Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlTWF0Y2hGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWxhdGl2ZUluZGV4ICYmICFyZWxhdGl2ZU1hdGNoRm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkKGtleU5hbWUsIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgYnVpbGQobGluZUVuZCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hhbmdlZCAmJiAhbGluZUVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmhlYWRlcnMgPT09ICdzdHJpbmcnID8gQnVmZmVyLmZyb20odGhpcy5oZWFkZXJzLCAnYmluYXJ5JykgOiB0aGlzLmhlYWRlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVFbmQgPSBsaW5lRW5kIHx8ICdcXHJcXG4nO1xuXG4gICAgICAgIGxldCBoZWFkZXJzID0gdGhpcy5saW5lcy5tYXAobGluZSA9PiBsaW5lLmxpbmUucmVwbGFjZSgvXFxyP1xcbi9nLCBsaW5lRW5kKSkuam9pbihsaW5lRW5kKSArIGAke2xpbmVFbmR9JHtsaW5lRW5kfWA7XG5cbiAgICAgICAgaWYgKHRoaXMubWJveCkge1xuICAgICAgICAgICAgaGVhZGVycyA9IHRoaXMubWJveCArIGxpbmVFbmQgKyBoZWFkZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaHR0cCkge1xuICAgICAgICAgICAgaGVhZGVycyA9IHRoaXMuaHR0cCArIGxpbmVFbmQgKyBoZWFkZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhlYWRlcnMsICdiaW5hcnknKTtcbiAgICB9XG5cbiAgICBfbm9ybWFsaXplSGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gKGtleSB8fCAnJykudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgfVxuXG4gICAgX3BhcnNlSGVhZGVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsaW5lcyA9IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgLnRvU3RyaW5nKCdiaW5hcnknKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHJcXG5dKyQvLCAnJylcbiAgICAgICAgICAgIC5zcGxpdCgvXFxyP1xcbi8pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBsaW5lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNociA9IGxpbmVzW2ldLmNoYXJBdCgwKTtcbiAgICAgICAgICAgIGlmIChpICYmIChjaHIgPT09ICcgJyB8fCBjaHIgPT09ICdcXHQnKSkge1xuICAgICAgICAgICAgICAgIGxpbmVzW2kgLSAxXSArPSAnXFxyXFxuJyArIGxpbmVzW2ldO1xuICAgICAgICAgICAgICAgIGxpbmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWkgJiYgL15Gcm9tIC9pLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWJveCBmaWxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWJveCA9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaSAmJiAvXlBPU1QgL2kudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIVFRQIFBPU1QgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmh0dHAgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5fbm9ybWFsaXplSGVhZGVyKGxpbmUuc3Vic3RyKDAsIGxpbmUuaW5kZXhPZignOicpKSk7XG4gICAgICAgICAgICAgICAgbGluZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgbGluZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgICAgIHRoaXMucGFyc2VkID0gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIGV4cG9zZSB0byB0aGUgd29ybGRcbm1vZHVsZS5leHBvcnRzID0gSGVhZGVycztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/headers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-joiner.js":
/*!***************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/message-joiner.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\n\nclass MessageJoiner extends Transform {\n    constructor() {\n        let options = {\n            readableObjectMode: false,\n            writableObjectMode: true\n        };\n        super(options);\n    }\n\n    _transform(obj, encoding, callback) {\n        if (Buffer.isBuffer(obj)) {\n            this.push(obj);\n        } else if (obj.type === 'node') {\n            this.push(obj.getHeaders());\n        } else if (obj.value) {\n            this.push(obj.value);\n        }\n        return callback();\n    }\n\n    _flush(callback) {\n        return callback();\n    }\n}\n\nmodule.exports = MessageJoiner;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9tZXNzYWdlLWpvaW5lci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsdURBQTJCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvbHltYXJrZXQtYXJiaXRyYWdlLW5vZGUvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9tZXNzYWdlLWpvaW5lci5qcz85ZmI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xuXG5jbGFzcyBNZXNzYWdlSm9pbmVyIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByZWFkYWJsZU9iamVjdE1vZGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0ob2JqLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gob2JqKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoudHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gob2JqLmdldEhlYWRlcnMoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gob2JqLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VKb2luZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-joiner.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-splitter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/message-splitter.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst MimeNode = __webpack_require__(/*! ./mime-node */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/mime-node.js\");\n\nconst MAX_HEAD_SIZE = 1 * 1024 * 1024;\nconst MAX_CHILD_NODES = 1000;\n\nconst HEAD = 0x01;\nconst BODY = 0x02;\n\nclass MessageSplitter extends Transform {\n    constructor(config) {\n        let options = {\n            readableObjectMode: true,\n            writableObjectMode: false\n        };\n        super(options);\n\n        this.config = config || {};\n        this.maxHeadSize = this.config.maxHeadSize || MAX_HEAD_SIZE;\n        this.maxChildNodes = this.config.maxChildNodes || MAX_CHILD_NODES;\n        this.tree = [];\n        this.nodeCounter = 0;\n        this.newNode();\n        this.tree.push(this.node);\n        this.line = false;\n        this.hasFailed = false;\n    }\n\n    _transform(chunk, encoding, callback) {\n        // process line by line\n        // find next line ending\n        let pos = 0;\n        let i = 0;\n        let group = {\n            type: 'none'\n        };\n        let groupstart = this.line ? -this.line.length : 0;\n        let groupend = 0;\n\n        let checkTrailingLinebreak = data => {\n            if (data.type === 'body' && data.node.parentNode && data.value && data.value.length) {\n                if (data.value[data.value.length - 1] === 0x0a) {\n                    groupstart--;\n                    groupend--;\n                    pos--;\n                    if (data.value.length > 1 && data.value[data.value.length - 2] === 0x0d) {\n                        groupstart--;\n                        groupend--;\n                        pos--;\n                        if (groupstart < 0 && !this.line) {\n                            // store only <CR> as <LF> should be on the positive side\n                            this.line = Buffer.allocUnsafe(1);\n                            this.line[0] = 0x0d;\n                        }\n                        data.value = data.value.slice(0, data.value.length - 2);\n                    } else {\n                        data.value = data.value.slice(0, data.value.length - 1);\n                    }\n                } else if (data.value[data.value.length - 1] === 0x0d) {\n                    groupstart--;\n                    groupend--;\n                    pos--;\n                    data.value = data.value.slice(0, data.value.length - 1);\n                }\n            }\n        };\n\n        let iterateData = () => {\n            for (let len = chunk.length; i < len; i++) {\n                // find next <LF>\n                if (chunk[i] === 0x0a) {\n                    // line end\n\n                    let start = Math.max(pos, 0);\n                    pos = ++i;\n\n                    return this.processLine(chunk.slice(start, i), false, (err, data, flush) => {\n                        if (err) {\n                            this.hasFailed = true;\n                            return setImmediate(() => callback(err));\n                        }\n\n                        if (!data) {\n                            return setImmediate(iterateData);\n                        }\n\n                        if (flush) {\n                            if (group && group.type !== 'none') {\n                                if (group.type === 'body' && groupend >= groupstart && group.node.parentNode) {\n                                    // do not include the last line ending for body\n                                    if (chunk[groupend - 1] === 0x0a) {\n                                        groupend--;\n                                        if (groupend >= groupstart && chunk[groupend - 1] === 0x0d) {\n                                            groupend--;\n                                        }\n                                    }\n                                }\n                                if (groupstart !== groupend) {\n                                    group.value = chunk.slice(groupstart, groupend);\n                                    if (groupend < i) {\n                                        data.value = chunk.slice(groupend, i);\n                                    }\n                                }\n                                this.push(group);\n                                group = {\n                                    type: 'none'\n                                };\n                                groupstart = groupend = i;\n                            }\n                            this.push(data);\n                            groupend = i;\n                            return setImmediate(iterateData);\n                        }\n\n                        if (data.type === group.type) {\n                            // shift slice end position forward\n                            groupend = i;\n                        } else {\n                            if (group.type === 'body' && groupend >= groupstart && group.node.parentNode) {\n                                // do not include the last line ending for body\n                                if (chunk[groupend - 1] === 0x0a) {\n                                    groupend--;\n                                    if (groupend >= groupstart && chunk[groupend - 1] === 0x0d) {\n                                        groupend--;\n                                    }\n                                }\n                            }\n\n                            if (group.type !== 'none' && group.type !== 'node') {\n                                // we have a previous data/body chunk to output\n                                if (groupstart !== groupend) {\n                                    group.value = chunk.slice(groupstart, groupend);\n                                    if (group.value && group.value.length) {\n                                        this.push(group);\n                                        group = {\n                                            type: 'none'\n                                        };\n                                    }\n                                }\n                            }\n\n                            if (data.type === 'node') {\n                                this.push(data);\n                                groupstart = i;\n                                groupend = i;\n                            } else if (groupstart < 0) {\n                                groupstart = i;\n                                groupend = i;\n                                checkTrailingLinebreak(data);\n                                if (data.value && data.value.length) {\n                                    this.push(data);\n                                }\n                            } else {\n                                // start new body/data chunk\n                                group = data;\n                                groupstart = groupend;\n                                groupend = i;\n                            }\n                        }\n                        return setImmediate(iterateData);\n                    });\n                }\n            }\n\n            // skip last linebreak for body\n            if (pos >= groupstart + 1 && group.type === 'body' && group.node.parentNode) {\n                // do not include the last line ending for body\n                if (chunk[pos - 1] === 0x0a) {\n                    pos--;\n                    if (pos >= groupstart && chunk[pos - 1] === 0x0d) {\n                        pos--;\n                    }\n                }\n            }\n\n            if (group.type !== 'none' && group.type !== 'node' && pos > groupstart) {\n                // we have a leftover data/body chunk to push out\n                group.value = chunk.slice(groupstart, pos);\n\n                if (group.value && group.value.length) {\n                    this.push(group);\n                    group = {\n                        type: 'none'\n                    };\n                }\n            }\n\n            if (pos < chunk.length) {\n                if (this.line) {\n                    this.line = Buffer.concat([this.line, chunk.slice(pos)]);\n                } else {\n                    this.line = chunk.slice(pos);\n                }\n            }\n            callback();\n        };\n\n        setImmediate(iterateData);\n    }\n\n    _flush(callback) {\n        if (this.hasFailed) {\n            return callback();\n        }\n        this.processLine(false, true, (err, data) => {\n            if (err) {\n                return setImmediate(() => callback(err));\n            }\n            if (data && (data.type === 'node' || (data.value && data.value.length))) {\n                this.push(data);\n            }\n            callback();\n        });\n    }\n\n    compareBoundary(line, startpos, boundary) {\n        // --{boundary}\\r\\n or --{boundary}--\\r\\n\n        if (line.length < boundary.length + 3 + startpos || line.length > boundary.length + 6 + startpos) {\n            return false;\n        }\n        for (let i = 0; i < boundary.length; i++) {\n            if (line[i + 2 + startpos] !== boundary[i]) {\n                return false;\n            }\n        }\n\n        let pos = 0;\n        for (let i = boundary.length + 2 + startpos; i < line.length; i++) {\n            let c = line[i];\n            if (pos === 0 && (c === 0x0d || c === 0x0a)) {\n                // 1: next node\n                return 1;\n            }\n            if (pos === 0 && c !== 0x2d) {\n                // expecting \"-\"\n                return false;\n            }\n            if (pos === 1 && c !== 0x2d) {\n                // expecting \"-\"\n                return false;\n            }\n            if (pos === 2 && c !== 0x0d && c !== 0x0a) {\n                // expecting line terminator, either <CR> or <LF>\n                return false;\n            }\n            if (pos === 3 && c !== 0x0a) {\n                // expecting line terminator <LF>\n                return false;\n            }\n            pos++;\n        }\n\n        // 2: multipart end\n        return 2;\n    }\n\n    checkBoundary(line) {\n        let startpos = 0;\n        if (line.length >= 1 && (line[0] === 0x0d || line[0] === 0x0a)) {\n            startpos++;\n            if (line.length >= 2 && (line[0] === 0x0d || line[1] === 0x0a)) {\n                startpos++;\n            }\n        }\n        if (line.length < 4 || line[startpos] !== 0x2d || line[startpos + 1] !== 0x2d) {\n            // defnitely not a boundary\n            return false;\n        }\n\n        let boundary;\n        if (this.node._boundary && (boundary = this.compareBoundary(line, startpos, this.node._boundary))) {\n            // 1: next child\n            // 2: multipart end\n            return boundary;\n        }\n\n        if (this.node._parentBoundary && (boundary = this.compareBoundary(line, startpos, this.node._parentBoundary))) {\n            // 3: next sibling\n            // 4: parent end\n            return boundary + 2;\n        }\n\n        return false;\n    }\n\n    processLine(line, final, next) {\n        let flush = false;\n\n        if (this.line && line) {\n            line = Buffer.concat([this.line, line]);\n            this.line = false;\n        } else if (this.line && !line) {\n            line = this.line;\n            this.line = false;\n        }\n\n        if (!line) {\n            line = Buffer.alloc(0);\n        }\n\n        if (this.nodeCounter > this.maxChildNodes) {\n            let err = new Error('Max allowed child nodes exceeded');\n            err.code = 'EMAXLEN';\n            return next(err);\n        }\n\n        // we check boundary outside the HEAD/BODY scope as it may appear anywhere\n        let boundary = this.checkBoundary(line);\n        if (boundary) {\n            // reached boundary, switch context\n            switch (boundary) {\n                case 1:\n                    // next child\n                    this.newNode(this.node);\n                    flush = true;\n                    break;\n                case 2:\n                    // reached end of children, keep current node\n                    break;\n                case 3: {\n                    // next sibling\n                    let parentNode = this.node.parentNode;\n                    if (parentNode && parentNode.contentType === 'message/rfc822') {\n                        // special case where immediate parent is an inline message block\n                        // move up another step\n                        parentNode = parentNode.parentNode;\n                    }\n                    this.newNode(parentNode);\n                    flush = true;\n                    break;\n                }\n                case 4:\n                    // special case when boundary close a node with only header.\n                    if (this.node && this.node._headerlen && !this.node.headers) {\n                        this.node.parseHeaders();\n                        this.push(this.node);\n                    }\n                    // move up\n                    if (this.tree.length) {\n                        this.node = this.tree.pop();\n                    }\n                    this.state = BODY;\n                    break;\n            }\n\n            return next(\n                null,\n                {\n                    node: this.node,\n                    type: 'data',\n                    value: line\n                },\n                flush\n            );\n        }\n\n        switch (this.state) {\n            case HEAD: {\n                this.node.addHeaderChunk(line);\n                if (this.node._headerlen > this.maxHeadSize) {\n                    let err = new Error('Max header size for a MIME node exceeded');\n                    err.code = 'EMAXLEN';\n                    return next(err);\n                }\n                if (final || (line.length === 1 && line[0] === 0x0a) || (line.length === 2 && line[0] === 0x0d && line[1] === 0x0a)) {\n                    let currentNode = this.node;\n\n                    currentNode.parseHeaders();\n\n                    // if the content is attached message then just continue\n                    if (\n                        currentNode.contentType === 'message/rfc822' &&\n                        !this.config.ignoreEmbedded &&\n                        (!currentNode.encoding || ['7bit', '8bit', 'binary'].includes(currentNode.encoding)) &&\n                        (this.config.defaultInlineEmbedded ? currentNode.disposition !== 'attachment' : currentNode.disposition === 'inline')\n                    ) {\n                        currentNode.messageNode = true;\n                        this.newNode(currentNode);\n                        if (currentNode.parentNode) {\n                            this.node._parentBoundary = currentNode.parentNode._boundary;\n                        }\n                    } else {\n                        if (currentNode.contentType === 'message/rfc822') {\n                            currentNode.messageNode = false;\n                        }\n                        this.state = BODY;\n                        if (currentNode.multipart && currentNode._boundary) {\n                            this.tree.push(currentNode);\n                        }\n                    }\n\n                    return next(null, currentNode, flush);\n                }\n\n                return next();\n            }\n            case BODY: {\n                return next(\n                    null,\n                    {\n                        node: this.node,\n                        type: this.node.multipart ? 'data' : 'body',\n                        value: line\n                    },\n                    flush\n                );\n            }\n        }\n\n        next(null, false);\n    }\n\n    newNode(parent) {\n        this.node = new MimeNode(parent || false, this.config);\n        this.state = HEAD;\n        this.nodeCounter++;\n    }\n}\n\nmodule.exports = MessageSplitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9tZXNzYWdlLXNwbGl0dGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQix1REFBMkI7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsNkVBQWE7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGNBQWMsU0FBUyxXQUFXLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvbHltYXJrZXQtYXJiaXRyYWdlLW5vZGUvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9tZXNzYWdlLXNwbGl0dGVyLmpzP2ZiOTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG5jb25zdCBNaW1lTm9kZSA9IHJlcXVpcmUoJy4vbWltZS1ub2RlJyk7XG5cbmNvbnN0IE1BWF9IRUFEX1NJWkUgPSAxICogMTAyNCAqIDEwMjQ7XG5jb25zdCBNQVhfQ0hJTERfTk9ERVMgPSAxMDAwO1xuXG5jb25zdCBIRUFEID0gMHgwMTtcbmNvbnN0IEJPRFkgPSAweDAyO1xuXG5jbGFzcyBNZXNzYWdlU3BsaXR0ZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIHRoaXMubWF4SGVhZFNpemUgPSB0aGlzLmNvbmZpZy5tYXhIZWFkU2l6ZSB8fCBNQVhfSEVBRF9TSVpFO1xuICAgICAgICB0aGlzLm1heENoaWxkTm9kZXMgPSB0aGlzLmNvbmZpZy5tYXhDaGlsZE5vZGVzIHx8IE1BWF9DSElMRF9OT0RFUztcbiAgICAgICAgdGhpcy50cmVlID0gW107XG4gICAgICAgIHRoaXMubm9kZUNvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLm5ld05vZGUoKTtcbiAgICAgICAgdGhpcy50cmVlLnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgdGhpcy5saW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzRmFpbGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHByb2Nlc3MgbGluZSBieSBsaW5lXG4gICAgICAgIC8vIGZpbmQgbmV4dCBsaW5lIGVuZGluZ1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgZ3JvdXAgPSB7XG4gICAgICAgICAgICB0eXBlOiAnbm9uZSdcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGdyb3Vwc3RhcnQgPSB0aGlzLmxpbmUgPyAtdGhpcy5saW5lLmxlbmd0aCA6IDA7XG4gICAgICAgIGxldCBncm91cGVuZCA9IDA7XG5cbiAgICAgICAgbGV0IGNoZWNrVHJhaWxpbmdMaW5lYnJlYWsgPSBkYXRhID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdib2R5JyAmJiBkYXRhLm5vZGUucGFyZW50Tm9kZSAmJiBkYXRhLnZhbHVlICYmIGRhdGEudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudmFsdWVbZGF0YS52YWx1ZS5sZW5ndGggLSAxXSA9PT0gMHgwYSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cHN0YXJ0LS07XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwZW5kLS07XG4gICAgICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS52YWx1ZS5sZW5ndGggPiAxICYmIGRhdGEudmFsdWVbZGF0YS52YWx1ZS5sZW5ndGggLSAyXSA9PT0gMHgwZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzdGFydC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3Vwc3RhcnQgPCAwICYmICF0aGlzLmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBvbmx5IDxDUj4gYXMgPExGPiBzaG91bGQgYmUgb24gdGhlIHBvc2l0aXZlIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lWzBdID0gMHgwZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBkYXRhLnZhbHVlLnNsaWNlKDAsIGRhdGEudmFsdWUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gZGF0YS52YWx1ZS5zbGljZSgwLCBkYXRhLnZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnZhbHVlW2RhdGEudmFsdWUubGVuZ3RoIC0gMV0gPT09IDB4MGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzdGFydC0tO1xuICAgICAgICAgICAgICAgICAgICBncm91cGVuZC0tO1xuICAgICAgICAgICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IGRhdGEudmFsdWUuc2xpY2UoMCwgZGF0YS52YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGl0ZXJhdGVEYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbGVuID0gY2h1bmsubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIG5leHQgPExGPlxuICAgICAgICAgICAgICAgIGlmIChjaHVua1tpXSA9PT0gMHgwYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsaW5lIGVuZFxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgMCk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9ICsraTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzTGluZShjaHVuay5zbGljZShzdGFydCwgaSksIGZhbHNlLCAoZXJyLCBkYXRhLCBmbHVzaCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVycikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGl0ZXJhdGVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsdXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwICYmIGdyb3VwLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudHlwZSA9PT0gJ2JvZHknICYmIGdyb3VwZW5kID49IGdyb3Vwc3RhcnQgJiYgZ3JvdXAubm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgaW5jbHVkZSB0aGUgbGFzdCBsaW5lIGVuZGluZyBmb3IgYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rW2dyb3VwZW5kIC0gMV0gPT09IDB4MGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVuZC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cGVuZCA+PSBncm91cHN0YXJ0ICYmIGNodW5rW2dyb3VwZW5kIC0gMV0gPT09IDB4MGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3Vwc3RhcnQgIT09IGdyb3VwZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cC52YWx1ZSA9IGNodW5rLnNsaWNlKGdyb3Vwc3RhcnQsIGdyb3VwZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cGVuZCA8IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gY2h1bmsuc2xpY2UoZ3JvdXBlbmQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChncm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc3RhcnQgPSBncm91cGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShpdGVyYXRlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09IGdyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCBzbGljZSBlbmQgcG9zaXRpb24gZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLnR5cGUgPT09ICdib2R5JyAmJiBncm91cGVuZCA+PSBncm91cHN0YXJ0ICYmIGdyb3VwLm5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgaW5jbHVkZSB0aGUgbGFzdCBsaW5lIGVuZGluZyBmb3IgYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtbZ3JvdXBlbmQgLSAxXSA9PT0gMHgwYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cGVuZCA+PSBncm91cHN0YXJ0ICYmIGNodW5rW2dyb3VwZW5kIC0gMV0gPT09IDB4MGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVuZC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLnR5cGUgIT09ICdub25lJyAmJiBncm91cC50eXBlICE9PSAnbm9kZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIHByZXZpb3VzIGRhdGEvYm9keSBjaHVuayB0byBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3Vwc3RhcnQgIT09IGdyb3VwZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cC52YWx1ZSA9IGNodW5rLnNsaWNlKGdyb3Vwc3RhcnQsIGdyb3VwZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cC52YWx1ZSAmJiBncm91cC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdyb3Vwc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVHJhaWxpbmdMaW5lYnJlYWsoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnZhbHVlICYmIGRhdGEudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBuZXcgYm9keS9kYXRhIGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzdGFydCA9IGdyb3VwZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShpdGVyYXRlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2tpcCBsYXN0IGxpbmVicmVhayBmb3IgYm9keVxuICAgICAgICAgICAgaWYgKHBvcyA+PSBncm91cHN0YXJ0ICsgMSAmJiBncm91cC50eXBlID09PSAnYm9keScgJiYgZ3JvdXAubm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGluY2x1ZGUgdGhlIGxhc3QgbGluZSBlbmRpbmcgZm9yIGJvZHlcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtbcG9zIC0gMV0gPT09IDB4MGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZ3JvdXBzdGFydCAmJiBjaHVua1twb3MgLSAxXSA9PT0gMHgwZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChncm91cC50eXBlICE9PSAnbm9uZScgJiYgZ3JvdXAudHlwZSAhPT0gJ25vZGUnICYmIHBvcyA+IGdyb3Vwc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgbGVmdG92ZXIgZGF0YS9ib2R5IGNodW5rIHRvIHB1c2ggb3V0XG4gICAgICAgICAgICAgICAgZ3JvdXAudmFsdWUgPSBjaHVuay5zbGljZShncm91cHN0YXJ0LCBwb3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLnZhbHVlICYmIGdyb3VwLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICBncm91cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvcyA8IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lID0gQnVmZmVyLmNvbmNhdChbdGhpcy5saW5lLCBjaHVuay5zbGljZShwb3MpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lID0gY2h1bmsuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNldEltbWVkaWF0ZShpdGVyYXRlRGF0YSk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZhaWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzTGluZShmYWxzZSwgdHJ1ZSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAoZGF0YS50eXBlID09PSAnbm9kZScgfHwgKGRhdGEudmFsdWUgJiYgZGF0YS52YWx1ZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbXBhcmVCb3VuZGFyeShsaW5lLCBzdGFydHBvcywgYm91bmRhcnkpIHtcbiAgICAgICAgLy8gLS17Ym91bmRhcnl9XFxyXFxuIG9yIC0te2JvdW5kYXJ5fS0tXFxyXFxuXG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IGJvdW5kYXJ5Lmxlbmd0aCArIDMgKyBzdGFydHBvcyB8fCBsaW5lLmxlbmd0aCA+IGJvdW5kYXJ5Lmxlbmd0aCArIDYgKyBzdGFydHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRhcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2kgKyAyICsgc3RhcnRwb3NdICE9PSBib3VuZGFyeVtpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gYm91bmRhcnkubGVuZ3RoICsgMiArIHN0YXJ0cG9zOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGMgPSBsaW5lW2ldO1xuICAgICAgICAgICAgaWYgKHBvcyA9PT0gMCAmJiAoYyA9PT0gMHgwZCB8fCBjID09PSAweDBhKSkge1xuICAgICAgICAgICAgICAgIC8vIDE6IG5leHQgbm9kZVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA9PT0gMCAmJiBjICE9PSAweDJkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwZWN0aW5nIFwiLVwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA9PT0gMSAmJiBjICE9PSAweDJkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwZWN0aW5nIFwiLVwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA9PT0gMiAmJiBjICE9PSAweDBkICYmIGMgIT09IDB4MGEpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBlY3RpbmcgbGluZSB0ZXJtaW5hdG9yLCBlaXRoZXIgPENSPiBvciA8TEY+XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA9PT0gMyAmJiBjICE9PSAweDBhKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwZWN0aW5nIGxpbmUgdGVybWluYXRvciA8TEY+XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyOiBtdWx0aXBhcnQgZW5kXG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cblxuICAgIGNoZWNrQm91bmRhcnkobGluZSkge1xuICAgICAgICBsZXQgc3RhcnRwb3MgPSAwO1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPj0gMSAmJiAobGluZVswXSA9PT0gMHgwZCB8fCBsaW5lWzBdID09PSAweDBhKSkge1xuICAgICAgICAgICAgc3RhcnRwb3MrKztcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+PSAyICYmIChsaW5lWzBdID09PSAweDBkIHx8IGxpbmVbMV0gPT09IDB4MGEpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZS5sZW5ndGggPCA0IHx8IGxpbmVbc3RhcnRwb3NdICE9PSAweDJkIHx8IGxpbmVbc3RhcnRwb3MgKyAxXSAhPT0gMHgyZCkge1xuICAgICAgICAgICAgLy8gZGVmbml0ZWx5IG5vdCBhIGJvdW5kYXJ5XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYm91bmRhcnk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuX2JvdW5kYXJ5ICYmIChib3VuZGFyeSA9IHRoaXMuY29tcGFyZUJvdW5kYXJ5KGxpbmUsIHN0YXJ0cG9zLCB0aGlzLm5vZGUuX2JvdW5kYXJ5KSkpIHtcbiAgICAgICAgICAgIC8vIDE6IG5leHQgY2hpbGRcbiAgICAgICAgICAgIC8vIDI6IG11bHRpcGFydCBlbmRcbiAgICAgICAgICAgIHJldHVybiBib3VuZGFyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5vZGUuX3BhcmVudEJvdW5kYXJ5ICYmIChib3VuZGFyeSA9IHRoaXMuY29tcGFyZUJvdW5kYXJ5KGxpbmUsIHN0YXJ0cG9zLCB0aGlzLm5vZGUuX3BhcmVudEJvdW5kYXJ5KSkpIHtcbiAgICAgICAgICAgIC8vIDM6IG5leHQgc2libGluZ1xuICAgICAgICAgICAgLy8gNDogcGFyZW50IGVuZFxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kYXJ5ICsgMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwcm9jZXNzTGluZShsaW5lLCBmaW5hbCwgbmV4dCkge1xuICAgICAgICBsZXQgZmx1c2ggPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5saW5lICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGxpbmUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmxpbmUsIGxpbmVdKTtcbiAgICAgICAgICAgIHRoaXMubGluZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGluZSAmJiAhbGluZSkge1xuICAgICAgICAgICAgbGluZSA9IHRoaXMubGluZTtcbiAgICAgICAgICAgIHRoaXMubGluZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBsaW5lID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubm9kZUNvdW50ZXIgPiB0aGlzLm1heENoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoJ01heCBhbGxvd2VkIGNoaWxkIG5vZGVzIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICBlcnIuY29kZSA9ICdFTUFYTEVOJztcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBjaGVjayBib3VuZGFyeSBvdXRzaWRlIHRoZSBIRUFEL0JPRFkgc2NvcGUgYXMgaXQgbWF5IGFwcGVhciBhbnl3aGVyZVxuICAgICAgICBsZXQgYm91bmRhcnkgPSB0aGlzLmNoZWNrQm91bmRhcnkobGluZSk7XG4gICAgICAgIGlmIChib3VuZGFyeSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBib3VuZGFyeSwgc3dpdGNoIGNvbnRleHRcbiAgICAgICAgICAgIHN3aXRjaCAoYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdOb2RlKHRoaXMubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAvLyByZWFjaGVkIGVuZCBvZiBjaGlsZHJlbiwga2VlcCBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQgc2libGluZ1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IHRoaXMubm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9yZmM4MjInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugd2hlcmUgaW1tZWRpYXRlIHBhcmVudCBpcyBhbiBpbmxpbmUgbWVzc2FnZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB1cCBhbm90aGVyIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdOb2RlKHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBmbHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSB3aGVuIGJvdW5kYXJ5IGNsb3NlIGEgbm9kZSB3aXRoIG9ubHkgaGVhZGVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlICYmIHRoaXMubm9kZS5faGVhZGVybGVuICYmICF0aGlzLm5vZGUuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLnBhcnNlSGVhZGVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB1cFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gdGhpcy50cmVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBCT0RZO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5leHQoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHRoaXMubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGluZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmx1c2hcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgSEVBRDoge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hZGRIZWFkZXJDaHVuayhsaW5lKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlLl9oZWFkZXJsZW4gPiB0aGlzLm1heEhlYWRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoJ01heCBoZWFkZXIgc2l6ZSBmb3IgYSBNSU1FIG5vZGUgZXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSAnRU1BWExFTic7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaW5hbCB8fCAobGluZS5sZW5ndGggPT09IDEgJiYgbGluZVswXSA9PT0gMHgwYSkgfHwgKGxpbmUubGVuZ3RoID09PSAyICYmIGxpbmVbMF0gPT09IDB4MGQgJiYgbGluZVsxXSA9PT0gMHgwYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5ub2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnBhcnNlSGVhZGVycygpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjb250ZW50IGlzIGF0dGFjaGVkIG1lc3NhZ2UgdGhlbiBqdXN0IGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9yZmM4MjInICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5jb25maWcuaWdub3JlRW1iZWRkZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghY3VycmVudE5vZGUuZW5jb2RpbmcgfHwgWyc3Yml0JywgJzhiaXQnLCAnYmluYXJ5J10uaW5jbHVkZXMoY3VycmVudE5vZGUuZW5jb2RpbmcpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuY29uZmlnLmRlZmF1bHRJbmxpbmVFbWJlZGRlZCA/IGN1cnJlbnROb2RlLmRpc3Bvc2l0aW9uICE9PSAnYXR0YWNobWVudCcgOiBjdXJyZW50Tm9kZS5kaXNwb3NpdGlvbiA9PT0gJ2lubGluZScpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubWVzc2FnZU5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdOb2RlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLl9wYXJlbnRCb3VuZGFyeSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGUuX2JvdW5kYXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9yZmM4MjInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubWVzc2FnZU5vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBCT0RZO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLm11bHRpcGFydCAmJiBjdXJyZW50Tm9kZS5fYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWUucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChudWxsLCBjdXJyZW50Tm9kZSwgZmx1c2gpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJPRFk6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5ub2RlLm11bHRpcGFydCA/ICdkYXRhJyA6ICdib2R5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQobnVsbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIG5ld05vZGUocGFyZW50KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5ldyBNaW1lTm9kZShwYXJlbnQgfHwgZmFsc2UsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEhFQUQ7XG4gICAgICAgIHRoaXMubm9kZUNvdW50ZXIrKztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVNwbGl0dGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-splitter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/mime-node.js":
/*!**********************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/mime-node.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Headers = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/headers.js\");\nconst libmime = __webpack_require__(/*! libmime */ \"(rsc)/./node_modules/libmime/lib/libmime.js\");\nconst libqp = __webpack_require__(/*! libqp */ \"(rsc)/./node_modules/libqp/lib/libqp.js\");\nconst libbase64 = __webpack_require__(/*! libbase64 */ \"(rsc)/./node_modules/libbase64/lib/libbase64.js\");\nconst PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst pathlib = __webpack_require__(/*! path */ \"path\");\n\nclass MimeNode {\n    constructor(parentNode, config) {\n        this.type = 'node';\n        this.root = !parentNode;\n        this.parentNode = parentNode;\n\n        this._parentBoundary = this.parentNode && this.parentNode._boundary;\n        this._headersLines = [];\n        this._headerlen = 0;\n\n        this._parsedContentType = false;\n        this._boundary = false;\n\n        this.multipart = false;\n        this.encoding = false;\n        this.headers = false;\n        this.contentType = false;\n        this.flowed = false;\n        this.delSp = false;\n\n        this.config = config || {};\n        this.libmime = new libmime.Libmime({ Iconv: this.config.Iconv });\n\n        this.parentPartNumber = (parentNode && this.partNr) || [];\n        this.partNr = false; // resolved later\n        this.childPartNumbers = 0;\n    }\n\n    getPartNr(provided) {\n        if (provided) {\n            return []\n                .concat(this.partNr || [])\n                .filter(nr => !isNaN(nr))\n                .concat(provided);\n        }\n        let childPartNr = ++this.childPartNumbers;\n        return []\n            .concat(this.partNr || [])\n            .filter(nr => !isNaN(nr))\n            .concat(childPartNr);\n    }\n\n    addHeaderChunk(line) {\n        if (!line) {\n            return;\n        }\n        this._headersLines.push(line);\n        this._headerlen += line.length;\n    }\n\n    parseHeaders() {\n        if (this.headers) {\n            return;\n        }\n        this.headers = new Headers(Buffer.concat(this._headersLines, this._headerlen), this.config);\n\n        this._parsedContentDisposition = this.libmime.parseHeaderValue(this.headers.getFirst('Content-Disposition'));\n\n        // if content-type is missing default to plaintext\n        let contentHeader;\n        if (this.headers.get('Content-Type').length) {\n            contentHeader = this.headers.getFirst('Content-Type');\n        } else {\n            if (this._parsedContentDisposition.params.filename) {\n                let extension = pathlib.parse(this._parsedContentDisposition.params.filename).ext.replace(/^\\./, '');\n                if (extension) {\n                    contentHeader = libmime.detectMimeType(extension);\n                }\n            }\n            if (!contentHeader) {\n                if (/^attachment$/i.test(this._parsedContentDisposition.value)) {\n                    contentHeader = 'application/octet-stream';\n                } else {\n                    contentHeader = 'text/plain';\n                }\n            }\n        }\n\n        this._parsedContentType = this.libmime.parseHeaderValue(contentHeader);\n\n        this.encoding = this.headers\n            .getFirst('Content-Transfer-Encoding')\n            .replace(/\\(.*\\)/g, '')\n            .toLowerCase()\n            .trim();\n        this.contentType = (this._parsedContentType.value || '').toLowerCase().trim() || false;\n        this.charset = this._parsedContentType.params.charset || false;\n        this.disposition = (this._parsedContentDisposition.value || '').toLowerCase().trim() || false;\n\n        // fix invalidly encoded disposition values\n        if (this.disposition) {\n            try {\n                this.disposition = this.libmime.decodeWords(this.disposition);\n            } catch (E) {\n                // failed to parse disposition, keep as is (most probably an unknown charset is used)\n            }\n        }\n\n        this.filename = this._parsedContentDisposition.params.filename || this._parsedContentType.params.name || false;\n\n        if (this._parsedContentType.params.format && this._parsedContentType.params.format.toLowerCase().trim() === 'flowed') {\n            this.flowed = true;\n            if (this._parsedContentType.params.delsp && this._parsedContentType.params.delsp.toLowerCase().trim() === 'yes') {\n                this.delSp = true;\n            }\n        }\n\n        if (this.filename) {\n            try {\n                this.filename = this.libmime.decodeWords(this.filename);\n            } catch (E) {\n                // failed to parse filename, keep as is (most probably an unknown charset is used)\n            }\n        }\n\n        this.multipart =\n            (this.contentType &&\n                this.contentType.substr(0, this.contentType.indexOf('/')) === 'multipart' &&\n                this.contentType.substr(this.contentType.indexOf('/') + 1)) ||\n            false;\n        this._boundary = (this._parsedContentType.params.boundary && Buffer.from(this._parsedContentType.params.boundary)) || false;\n\n        this.rfc822 = this.contentType === 'message/rfc822';\n\n        if (!this.parentNode || this.parentNode.rfc822) {\n            this.partNr = this.parentNode ? this.parentNode.getPartNr('TEXT') : ['TEXT'];\n        } else {\n            this.partNr = this.parentNode ? this.parentNode.getPartNr() : [];\n        }\n    }\n\n    getHeaders() {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n        return this.headers.build();\n    }\n\n    setContentType(contentType) {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n\n        contentType = (contentType || '').toLowerCase().trim();\n        if (contentType) {\n            this._parsedContentType.value = contentType;\n        }\n\n        if (!this.flowed && this._parsedContentType.params.format) {\n            delete this._parsedContentType.params.format;\n        }\n\n        if (!this.delSp && this._parsedContentType.params.delsp) {\n            delete this._parsedContentType.params.delsp;\n        }\n\n        this.headers.update('Content-Type', this.libmime.buildHeaderValue(this._parsedContentType));\n    }\n\n    setCharset(charset) {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n\n        charset = (charset || '').toLowerCase().trim();\n\n        if (charset === 'ascii') {\n            charset = '';\n        }\n\n        if (!charset) {\n            if (!this._parsedContentType.value) {\n                // nothing to set or update\n                return;\n            }\n            delete this._parsedContentType.params.charset;\n        } else {\n            this._parsedContentType.params.charset = charset;\n        }\n\n        if (!this._parsedContentType.value) {\n            this._parsedContentType.value = 'text/plain';\n        }\n\n        this.headers.update('Content-Type', this.libmime.buildHeaderValue(this._parsedContentType));\n    }\n\n    setFilename(filename) {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n\n        this.filename = (filename || '').toLowerCase().trim();\n\n        if (this._parsedContentType.params.name) {\n            delete this._parsedContentType.params.name;\n            this.headers.update('Content-Type', this.libmime.buildHeaderValue(this._parsedContentType));\n        }\n\n        if (!this.filename) {\n            if (!this._parsedContentDisposition.value) {\n                // nothing to set or update\n                return;\n            }\n            delete this._parsedContentDisposition.params.filename;\n        } else {\n            this._parsedContentDisposition.params.filename = this.filename;\n        }\n\n        if (!this._parsedContentDisposition.value) {\n            this._parsedContentDisposition.value = 'attachment';\n        }\n\n        this.headers.update('Content-Disposition', this.libmime.buildHeaderValue(this._parsedContentDisposition));\n    }\n\n    getDecoder() {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n\n        switch (this.encoding) {\n            case 'base64':\n                return new libbase64.Decoder();\n            case 'quoted-printable':\n                return new libqp.Decoder();\n            default:\n                return new PassThrough();\n        }\n    }\n\n    getEncoder(encoding) {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n\n        encoding = (encoding || '').toString().toLowerCase().trim();\n\n        if (encoding && encoding !== this.encoding) {\n            this.headers.update('Content-Transfer-Encoding', encoding);\n        } else {\n            encoding = this.encoding;\n        }\n\n        switch (encoding) {\n            case 'base64':\n                return new libbase64.Encoder();\n            case 'quoted-printable':\n                return new libqp.Encoder();\n            default:\n                return new PassThrough();\n        }\n    }\n}\n\nmodule.exports = MimeNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9taW1lLW5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVM7QUFDakMsY0FBYyxtQkFBTyxDQUFDLHNEQUFPO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLGtFQUFXO0FBQ3JDLG9CQUFvQix5REFBNkI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsa0JBQU07O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLDBCQUEwQjs7QUFFdkU7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvbHltYXJrZXQtYXJiaXRyYWdlLW5vZGUvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9taW1lLW5vZGUuanM/YzQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhlYWRlcnMgPSByZXF1aXJlKCcuL2hlYWRlcnMnKTtcbmNvbnN0IGxpYm1pbWUgPSByZXF1aXJlKCdsaWJtaW1lJyk7XG5jb25zdCBsaWJxcCA9IHJlcXVpcmUoJ2xpYnFwJyk7XG5jb25zdCBsaWJiYXNlNjQgPSByZXF1aXJlKCdsaWJiYXNlNjQnKTtcbmNvbnN0IFBhc3NUaHJvdWdoID0gcmVxdWlyZSgnc3RyZWFtJykuUGFzc1Rocm91Z2g7XG5jb25zdCBwYXRobGliID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jbGFzcyBNaW1lTm9kZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50Tm9kZSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdub2RlJztcbiAgICAgICAgdGhpcy5yb290ID0gIXBhcmVudE5vZGU7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG5cbiAgICAgICAgdGhpcy5fcGFyZW50Qm91bmRhcnkgPSB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLl9ib3VuZGFyeTtcbiAgICAgICAgdGhpcy5faGVhZGVyc0xpbmVzID0gW107XG4gICAgICAgIHRoaXMuX2hlYWRlcmxlbiA9IDA7XG5cbiAgICAgICAgdGhpcy5fcGFyc2VkQ29udGVudFR5cGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYm91bmRhcnkgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLm11bHRpcGFydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmxvd2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsU3AgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdGhpcy5saWJtaW1lID0gbmV3IGxpYm1pbWUuTGlibWltZSh7IEljb252OiB0aGlzLmNvbmZpZy5JY29udiB9KTtcblxuICAgICAgICB0aGlzLnBhcmVudFBhcnROdW1iZXIgPSAocGFyZW50Tm9kZSAmJiB0aGlzLnBhcnROcikgfHwgW107XG4gICAgICAgIHRoaXMucGFydE5yID0gZmFsc2U7IC8vIHJlc29sdmVkIGxhdGVyXG4gICAgICAgIHRoaXMuY2hpbGRQYXJ0TnVtYmVycyA9IDA7XG4gICAgfVxuXG4gICAgZ2V0UGFydE5yKHByb3ZpZGVkKSB7XG4gICAgICAgIGlmIChwcm92aWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLnBhcnROciB8fCBbXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKG5yID0+ICFpc05hTihucikpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChwcm92aWRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkUGFydE5yID0gKyt0aGlzLmNoaWxkUGFydE51bWJlcnM7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgICAgICAgLmNvbmNhdCh0aGlzLnBhcnROciB8fCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIobnIgPT4gIWlzTmFOKG5yKSlcbiAgICAgICAgICAgIC5jb25jYXQoY2hpbGRQYXJ0TnIpO1xuICAgIH1cblxuICAgIGFkZEhlYWRlckNodW5rKGxpbmUpIHtcbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZGVyc0xpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIHRoaXMuX2hlYWRlcmxlbiArPSBsaW5lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBwYXJzZUhlYWRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhCdWZmZXIuY29uY2F0KHRoaXMuX2hlYWRlcnNMaW5lcywgdGhpcy5faGVhZGVybGVuKSwgdGhpcy5jb25maWcpO1xuXG4gICAgICAgIHRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbiA9IHRoaXMubGlibWltZS5wYXJzZUhlYWRlclZhbHVlKHRoaXMuaGVhZGVycy5nZXRGaXJzdCgnQ29udGVudC1EaXNwb3NpdGlvbicpKTtcblxuICAgICAgICAvLyBpZiBjb250ZW50LXR5cGUgaXMgbWlzc2luZyBkZWZhdWx0IHRvIHBsYWludGV4dFxuICAgICAgICBsZXQgY29udGVudEhlYWRlcjtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGVudEhlYWRlciA9IHRoaXMuaGVhZGVycy5nZXRGaXJzdCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyc2VkQ29udGVudERpc3Bvc2l0aW9uLnBhcmFtcy5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIGxldCBleHRlbnNpb24gPSBwYXRobGliLnBhcnNlKHRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbi5wYXJhbXMuZmlsZW5hbWUpLmV4dC5yZXBsYWNlKC9eXFwuLywgJycpO1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhlYWRlciA9IGxpYm1pbWUuZGV0ZWN0TWltZVR5cGUoZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnRIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoL15hdHRhY2htZW50JC9pLnRlc3QodGhpcy5fcGFyc2VkQ29udGVudERpc3Bvc2l0aW9uLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50SGVhZGVyID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhlYWRlciA9ICd0ZXh0L3BsYWluJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXJzZWRDb250ZW50VHlwZSA9IHRoaXMubGlibWltZS5wYXJzZUhlYWRlclZhbHVlKGNvbnRlbnRIZWFkZXIpO1xuXG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSB0aGlzLmhlYWRlcnNcbiAgICAgICAgICAgIC5nZXRGaXJzdCgnQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoLipcXCkvZywgJycpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9ICh0aGlzLl9wYXJzZWRDb250ZW50VHlwZS52YWx1ZSB8fCAnJykudG9Mb3dlckNhc2UoKS50cmltKCkgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhcnNldCA9IHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5jaGFyc2V0IHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3Bvc2l0aW9uID0gKHRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbi52YWx1ZSB8fCAnJykudG9Mb3dlckNhc2UoKS50cmltKCkgfHwgZmFsc2U7XG5cbiAgICAgICAgLy8gZml4IGludmFsaWRseSBlbmNvZGVkIGRpc3Bvc2l0aW9uIHZhbHVlc1xuICAgICAgICBpZiAodGhpcy5kaXNwb3NpdGlvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2l0aW9uID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHRoaXMuZGlzcG9zaXRpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgIC8vIGZhaWxlZCB0byBwYXJzZSBkaXNwb3NpdGlvbiwga2VlcCBhcyBpcyAobW9zdCBwcm9iYWJseSBhbiB1bmtub3duIGNoYXJzZXQgaXMgdXNlZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSB0aGlzLl9wYXJzZWRDb250ZW50RGlzcG9zaXRpb24ucGFyYW1zLmZpbGVuYW1lIHx8IHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5uYW1lIHx8IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuZm9ybWF0ICYmIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5mb3JtYXQudG9Mb3dlckNhc2UoKS50cmltKCkgPT09ICdmbG93ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmZsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyc2VkQ29udGVudFR5cGUucGFyYW1zLmRlbHNwICYmIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5kZWxzcC50b0xvd2VyQ2FzZSgpLnRyaW0oKSA9PT0gJ3llcycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbFNwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZW5hbWUgPSB0aGlzLmxpYm1pbWUuZGVjb2RlV29yZHModGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFpbGVkIHRvIHBhcnNlIGZpbGVuYW1lLCBrZWVwIGFzIGlzIChtb3N0IHByb2JhYmx5IGFuIHVua25vd24gY2hhcnNldCBpcyB1c2VkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tdWx0aXBhcnQgPVxuICAgICAgICAgICAgKHRoaXMuY29udGVudFR5cGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlLnN1YnN0cigwLCB0aGlzLmNvbnRlbnRUeXBlLmluZGV4T2YoJy8nKSkgPT09ICdtdWx0aXBhcnQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50VHlwZS5zdWJzdHIodGhpcy5jb250ZW50VHlwZS5pbmRleE9mKCcvJykgKyAxKSkgfHxcbiAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICB0aGlzLl9ib3VuZGFyeSA9ICh0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuYm91bmRhcnkgJiYgQnVmZmVyLmZyb20odGhpcy5fcGFyc2VkQ29udGVudFR5cGUucGFyYW1zLmJvdW5kYXJ5KSkgfHwgZmFsc2U7XG5cbiAgICAgICAgdGhpcy5yZmM4MjIgPSB0aGlzLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9yZmM4MjInO1xuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnROb2RlIHx8IHRoaXMucGFyZW50Tm9kZS5yZmM4MjIpIHtcbiAgICAgICAgICAgIHRoaXMucGFydE5yID0gdGhpcy5wYXJlbnROb2RlID8gdGhpcy5wYXJlbnROb2RlLmdldFBhcnROcignVEVYVCcpIDogWydURVhUJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnROciA9IHRoaXMucGFyZW50Tm9kZSA/IHRoaXMucGFyZW50Tm9kZS5nZXRQYXJ0TnIoKSA6IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVycy5idWlsZCgpO1xuICAgIH1cblxuICAgIHNldENvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudFR5cGUgPSAoY29udGVudFR5cGUgfHwgJycpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnZhbHVlID0gY29udGVudFR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZmxvd2VkICYmIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5mb3JtYXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmRlbFNwICYmIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5kZWxzcCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5kZWxzcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGVhZGVycy51cGRhdGUoJ0NvbnRlbnQtVHlwZScsIHRoaXMubGlibWltZS5idWlsZEhlYWRlclZhbHVlKHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlKSk7XG4gICAgfVxuXG4gICAgc2V0Q2hhcnNldChjaGFyc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnNldCA9IChjaGFyc2V0IHx8ICcnKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblxuICAgICAgICBpZiAoY2hhcnNldCA9PT0gJ2FzY2lpJykge1xuICAgICAgICAgICAgY2hhcnNldCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaGFyc2V0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyB0byBzZXQgb3IgdXBkYXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5jaGFyc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VkQ29udGVudFR5cGUucGFyYW1zLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9wYXJzZWRDb250ZW50VHlwZS52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VkQ29udGVudFR5cGUudmFsdWUgPSAndGV4dC9wbGFpbic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhlYWRlcnMudXBkYXRlKCdDb250ZW50LVR5cGUnLCB0aGlzLmxpYm1pbWUuYnVpbGRIZWFkZXJWYWx1ZSh0aGlzLl9wYXJzZWRDb250ZW50VHlwZSkpO1xuICAgIH1cblxuICAgIHNldEZpbGVuYW1lKGZpbGVuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IChmaWxlbmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5uYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcGFyc2VkQ29udGVudFR5cGUucGFyYW1zLm5hbWU7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMudXBkYXRlKCdDb250ZW50LVR5cGUnLCB0aGlzLmxpYm1pbWUuYnVpbGRIZWFkZXJWYWx1ZSh0aGlzLl9wYXJzZWRDb250ZW50VHlwZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gc2V0IG9yIHVwZGF0ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wYXJzZWRDb250ZW50RGlzcG9zaXRpb24ucGFyYW1zLmZpbGVuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VkQ29udGVudERpc3Bvc2l0aW9uLnBhcmFtcy5maWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VkQ29udGVudERpc3Bvc2l0aW9uLnZhbHVlID0gJ2F0dGFjaG1lbnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oZWFkZXJzLnVwZGF0ZSgnQ29udGVudC1EaXNwb3NpdGlvbicsIHRoaXMubGlibWltZS5idWlsZEhlYWRlclZhbHVlKHRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbikpO1xuICAgIH1cblxuICAgIGdldERlY29kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgICAgICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbGliYmFzZTY0LkRlY29kZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3F1b3RlZC1wcmludGFibGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbGlicXAuRGVjb2RlcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRFbmNvZGVyKGVuY29kaW5nKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJycpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nICYmIGVuY29kaW5nICE9PSB0aGlzLmVuY29kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMudXBkYXRlKCdDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nJywgZW5jb2RpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGxpYmJhc2U2NC5FbmNvZGVyKCk7XG4gICAgICAgICAgICBjYXNlICdxdW90ZWQtcHJpbnRhYmxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGxpYnFwLkVuY29kZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1pbWVOb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/mime-node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-rewriter.js":
/*!**************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/node-rewriter.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// Helper class to rewrite nodes with specific mime type\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst FlowedDecoder = __webpack_require__(/*! ./flowed-decoder */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js\");\n\n/**\n * NodeRewriter Transform stream. Updates content for all nodes with specified mime type\n *\n * @constructor\n * @param {String} mimeType Define the Mime-Type to look for\n * @param {Function} rewriteAction Function to run with the node content\n */\nclass NodeRewriter extends Transform {\n    constructor(filterFunc, rewriteAction) {\n        let options = {\n            readableObjectMode: true,\n            writableObjectMode: true\n        };\n        super(options);\n\n        this.filterFunc = filterFunc;\n        this.rewriteAction = rewriteAction;\n\n        this.decoder = false;\n        this.encoder = false;\n        this.continue = false;\n    }\n\n    _transform(data, encoding, callback) {\n        this.processIncoming(data, callback);\n    }\n\n    _flush(callback) {\n        if (this.decoder) {\n            // emit an empty node just in case there is pending data to end\n            return this.processIncoming(\n                {\n                    type: 'none'\n                },\n                callback\n            );\n        }\n        return callback();\n    }\n\n    processIncoming(data, callback) {\n        if (this.decoder && data.type === 'body') {\n            // data to parse\n            if (!this.decoder.write(data.value)) {\n                return this.decoder.once('drain', callback);\n            } else {\n                return callback();\n            }\n        } else if (this.decoder && data.type !== 'body') {\n            // stop decoding.\n            // we can not process the current data chunk as we need to wait until\n            // the parsed data is completely processed, so we store a reference to the\n            // continue callback\n            this.continue = () => {\n                this.continue = false;\n                this.decoder = false;\n                this.encoder = false;\n                this.processIncoming(data, callback);\n            };\n            return this.decoder.end();\n        } else if (data.type === 'node' && this.filterFunc(data)) {\n            // found matching node, create new handler\n            this.emit('node', this.createDecodePair(data));\n        } else if (this.readable && data.type !== 'none') {\n            // we don't care about this data, just pass it over to the joiner\n            this.push(data);\n        }\n        callback();\n    }\n\n    createDecodePair(node) {\n        this.decoder = node.getDecoder();\n\n        if (['base64', 'quoted-printable'].includes(node.encoding)) {\n            this.encoder = node.getEncoder();\n        } else {\n            this.encoder = node.getEncoder('quoted-printable');\n        }\n\n        let lastByte = false;\n\n        let decoder = this.decoder;\n        let encoder = this.encoder;\n        let firstChunk = true;\n        decoder.$reading = false;\n\n        let readFromEncoder = () => {\n            decoder.$reading = true;\n\n            let data = encoder.read();\n            if (data === null) {\n                decoder.$reading = false;\n                return;\n            }\n\n            if (firstChunk) {\n                firstChunk = false;\n                if (this.readable) {\n                    this.push(node);\n                    if (node.type === 'body') {\n                        lastByte = node.value && node.value.length && node.value[node.value.length - 1];\n                    }\n                }\n            }\n\n            let writeMore = true;\n            if (this.readable) {\n                writeMore = this.push({\n                    node,\n                    type: 'body',\n                    value: data\n                });\n                lastByte = data && data.length && data[data.length - 1];\n            }\n\n            if (writeMore) {\n                return setImmediate(readFromEncoder);\n            } else {\n                encoder.pause();\n                // no idea how to catch drain? use timeout for now as poor man's substitute\n                // this.once('drain', () => encoder.resume());\n                setTimeout(() => {\n                    encoder.resume();\n                    setImmediate(readFromEncoder);\n                }, 100);\n            }\n        };\n\n        encoder.on('readable', () => {\n            if (!decoder.$reading) {\n                return readFromEncoder();\n            }\n        });\n\n        encoder.on('end', () => {\n            if (firstChunk) {\n                firstChunk = false;\n                if (this.readable) {\n                    this.push(node);\n                    if (node.type === 'body') {\n                        lastByte = node.value && node.value.length && node.value[node.value.length - 1];\n                    }\n                }\n            }\n\n            if (lastByte !== 0x0a) {\n                // make sure there is a terminating line break\n                this.push({\n                    node,\n                    type: 'body',\n                    value: Buffer.from([0x0a])\n                });\n            }\n\n            if (this.continue) {\n                return this.continue();\n            }\n        });\n\n        if (/^text\\//.test(node.contentType) && node.flowed) {\n            // text/plain; format=flowed is a special case\n            let flowDecoder = decoder;\n            decoder = new FlowedDecoder({\n                delSp: node.delSp,\n                encoding: node.encoding\n            });\n            flowDecoder.on('error', err => {\n                decoder.emit('error', err);\n            });\n            flowDecoder.pipe(decoder);\n\n            // we don't know what kind of data we are going to get, does it comply with the\n            // requirements of format=flowed, so we just cancel it\n            node.flowed = false;\n            node.delSp = false;\n            node.setContentType();\n        }\n\n        return {\n            node,\n            decoder,\n            encoder\n        };\n    }\n}\n\nmodule.exports = NodeRewriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9ub2RlLXJld3JpdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLGtCQUFrQix1REFBMkI7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMsdUZBQWtCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvbHltYXJrZXQtYXJiaXRyYWdlLW5vZGUvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9ub2RlLXJld3JpdGVyLmpzP2FhMmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBIZWxwZXIgY2xhc3MgdG8gcmV3cml0ZSBub2RlcyB3aXRoIHNwZWNpZmljIG1pbWUgdHlwZVxuXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG5jb25zdCBGbG93ZWREZWNvZGVyID0gcmVxdWlyZSgnLi9mbG93ZWQtZGVjb2RlcicpO1xuXG4vKipcbiAqIE5vZGVSZXdyaXRlciBUcmFuc2Zvcm0gc3RyZWFtLiBVcGRhdGVzIGNvbnRlbnQgZm9yIGFsbCBub2RlcyB3aXRoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSBEZWZpbmUgdGhlIE1pbWUtVHlwZSB0byBsb29rIGZvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmV3cml0ZUFjdGlvbiBGdW5jdGlvbiB0byBydW4gd2l0aCB0aGUgbm9kZSBjb250ZW50XG4gKi9cbmNsYXNzIE5vZGVSZXdyaXRlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyRnVuYywgcmV3cml0ZUFjdGlvbikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmZpbHRlckZ1bmMgPSBmaWx0ZXJGdW5jO1xuICAgICAgICB0aGlzLnJld3JpdGVBY3Rpb24gPSByZXdyaXRlQWN0aW9uO1xuXG4gICAgICAgIHRoaXMuZGVjb2RlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250aW51ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc0luY29taW5nKGRhdGEsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZGVjb2Rlcikge1xuICAgICAgICAgICAgLy8gZW1pdCBhbiBlbXB0eSBub2RlIGp1c3QgaW4gY2FzZSB0aGVyZSBpcyBwZW5kaW5nIGRhdGEgdG8gZW5kXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzSW5jb21pbmcoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbm9uZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHByb2Nlc3NJbmNvbWluZyhkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5kZWNvZGVyICYmIGRhdGEudHlwZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBkYXRhIHRvIHBhcnNlXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVjb2Rlci53cml0ZShkYXRhLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZXIub25jZSgnZHJhaW4nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVjb2RlciAmJiBkYXRhLnR5cGUgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gc3RvcCBkZWNvZGluZy5cbiAgICAgICAgICAgIC8vIHdlIGNhbiBub3QgcHJvY2VzcyB0aGUgY3VycmVudCBkYXRhIGNodW5rIGFzIHdlIG5lZWQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAgICAgLy8gdGhlIHBhcnNlZCBkYXRhIGlzIGNvbXBsZXRlbHkgcHJvY2Vzc2VkLCBzbyB3ZSBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbmNvbWluZyhkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5lbmQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdub2RlJyAmJiB0aGlzLmZpbHRlckZ1bmMoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIG1hdGNoaW5nIG5vZGUsIGNyZWF0ZSBuZXcgaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdub2RlJywgdGhpcy5jcmVhdGVEZWNvZGVQYWlyKGRhdGEpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlYWRhYmxlICYmIGRhdGEudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgZGF0YSwganVzdCBwYXNzIGl0IG92ZXIgdG8gdGhlIGpvaW5lclxuICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVjb2RlUGFpcihub2RlKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5vZGUuZ2V0RGVjb2RlcigpO1xuXG4gICAgICAgIGlmIChbJ2Jhc2U2NCcsICdxdW90ZWQtcHJpbnRhYmxlJ10uaW5jbHVkZXMobm9kZS5lbmNvZGluZykpIHtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlciA9IG5vZGUuZ2V0RW5jb2RlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVyID0gbm9kZS5nZXRFbmNvZGVyKCdxdW90ZWQtcHJpbnRhYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGFzdEJ5dGUgPSBmYWxzZTtcblxuICAgICAgICBsZXQgZGVjb2RlciA9IHRoaXMuZGVjb2RlcjtcbiAgICAgICAgbGV0IGVuY29kZXIgPSB0aGlzLmVuY29kZXI7XG4gICAgICAgIGxldCBmaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgZGVjb2Rlci4kcmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGxldCByZWFkRnJvbUVuY29kZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBkZWNvZGVyLiRyZWFkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgbGV0IGRhdGEgPSBlbmNvZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci4kcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpcnN0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICBmaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCeXRlID0gbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlLmxlbmd0aCAmJiBub2RlLnZhbHVlW25vZGUudmFsdWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB3cml0ZU1vcmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZGFibGUpIHtcbiAgICAgICAgICAgICAgICB3cml0ZU1vcmUgPSB0aGlzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGFzdEJ5dGUgPSBkYXRhICYmIGRhdGEubGVuZ3RoICYmIGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdyaXRlTW9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUocmVhZEZyb21FbmNvZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rlci5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIC8vIG5vIGlkZWEgaG93IHRvIGNhdGNoIGRyYWluPyB1c2UgdGltZW91dCBmb3Igbm93IGFzIHBvb3IgbWFuJ3Mgc3Vic3RpdHV0ZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMub25jZSgnZHJhaW4nLCAoKSA9PiBlbmNvZGVyLnJlc3VtZSgpKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKHJlYWRGcm9tRW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBlbmNvZGVyLm9uKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZGVjb2Rlci4kcmVhZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkRnJvbUVuY29kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW5jb2Rlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpcnN0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICBmaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCeXRlID0gbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlLmxlbmd0aCAmJiBub2RlLnZhbHVlW25vZGUudmFsdWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYXN0Qnl0ZSAhPT0gMHgwYSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIHRlcm1pbmF0aW5nIGxpbmUgYnJlYWtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBCdWZmZXIuZnJvbShbMHgwYV0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGludWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKC9edGV4dFxcLy8udGVzdChub2RlLmNvbnRlbnRUeXBlKSAmJiBub2RlLmZsb3dlZCkge1xuICAgICAgICAgICAgLy8gdGV4dC9wbGFpbjsgZm9ybWF0PWZsb3dlZCBpcyBhIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgbGV0IGZsb3dEZWNvZGVyID0gZGVjb2RlcjtcbiAgICAgICAgICAgIGRlY29kZXIgPSBuZXcgRmxvd2VkRGVjb2Rlcih7XG4gICAgICAgICAgICAgICAgZGVsU3A6IG5vZGUuZGVsU3AsXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IG5vZGUuZW5jb2RpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmxvd0RlY29kZXIub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmxvd0RlY29kZXIucGlwZShkZWNvZGVyKTtcblxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGF0IGtpbmQgb2YgZGF0YSB3ZSBhcmUgZ29pbmcgdG8gZ2V0LCBkb2VzIGl0IGNvbXBseSB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnRzIG9mIGZvcm1hdD1mbG93ZWQsIHNvIHdlIGp1c3QgY2FuY2VsIGl0XG4gICAgICAgICAgICBub2RlLmZsb3dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5kZWxTcCA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5zZXRDb250ZW50VHlwZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBkZWNvZGVyLFxuICAgICAgICAgICAgZW5jb2RlclxuICAgICAgICB9O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlUmV3cml0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-rewriter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-streamer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/node-streamer.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// Helper class to rewrite nodes with specific mime type\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst FlowedDecoder = __webpack_require__(/*! ./flowed-decoder */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js\");\n\n/**\n * NodeRewriter Transform stream. Updates content for all nodes with specified mime type\n *\n * @constructor\n * @param {String} mimeType Define the Mime-Type to look for\n * @param {Function} streamAction Function to run with the node content\n */\nclass NodeStreamer extends Transform {\n    constructor(filterFunc, streamAction) {\n        let options = {\n            readableObjectMode: true,\n            writableObjectMode: true\n        };\n        super(options);\n\n        this.filterFunc = filterFunc;\n        this.streamAction = streamAction;\n\n        this.decoder = false;\n        this.canContinue = false;\n        this.continue = false;\n    }\n\n    _transform(data, encoding, callback) {\n        this.processIncoming(data, callback);\n    }\n\n    _flush(callback) {\n        if (this.decoder) {\n            // emit an empty node just in case there is pending data to end\n            return this.processIncoming(\n                {\n                    type: 'none'\n                },\n                callback\n            );\n        }\n        return callback();\n    }\n\n    processIncoming(data, callback) {\n        if (this.decoder && data.type === 'body') {\n            // data to parse\n            this.push(data);\n            if (!this.decoder.write(data.value)) {\n                return this.decoder.once('drain', callback);\n            } else {\n                return callback();\n            }\n        } else if (this.decoder && data.type !== 'body') {\n            // stop decoding.\n            // we can not process the current data chunk as we need to wait until\n            // the parsed data is completely processed, so we store a reference to the\n            // continue callback\n\n            let doContinue = () => {\n                this.continue = false;\n                this.decoder = false;\n                this.canContinue = false;\n                this.processIncoming(data, callback);\n            };\n\n            if (this.canContinue) {\n                setImmediate(doContinue);\n            } else {\n                this.continue = () => doContinue();\n            }\n\n            return this.decoder.end();\n        } else if (data.type === 'node' && this.filterFunc(data)) {\n            this.push(data);\n            // found matching node, create new handler\n            this.emit('node', this.createDecoder(data));\n        } else if (this.readable && data.type !== 'none') {\n            // we don't care about this data, just pass it over to the joiner\n            this.push(data);\n        }\n        callback();\n    }\n\n    createDecoder(node) {\n        this.decoder = node.getDecoder();\n\n        let decoder = this.decoder;\n        decoder.$reading = false;\n\n        if (/^text\\//.test(node.contentType) && node.flowed) {\n            let flowDecoder = decoder;\n            decoder = new FlowedDecoder({\n                delSp: node.delSp\n            });\n            flowDecoder.on('error', err => {\n                decoder.emit('error', err);\n            });\n            flowDecoder.pipe(decoder);\n        }\n\n        return {\n            node,\n            decoder,\n            done: () => {\n                if (typeof this.continue === 'function') {\n                    // called once input stream is processed\n                    this.continue();\n                } else {\n                    // called before input stream is processed\n                    this.canContinue = true;\n                }\n            }\n        };\n    }\n}\n\nmodule.exports = NodeStreamer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9ub2RlLXN0cmVhbWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLGtCQUFrQix1REFBMkI7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMsdUZBQWtCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2x5bWFya2V0LWFyYml0cmFnZS1ub2RlLy4vbm9kZV9tb2R1bGVzL0B6b25lLWV1L21haWxzcGxpdC9saWIvbm9kZS1zdHJlYW1lci5qcz9hZTY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gSGVscGVyIGNsYXNzIHRvIHJld3JpdGUgbm9kZXMgd2l0aCBzcGVjaWZpYyBtaW1lIHR5cGVcblxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xuY29uc3QgRmxvd2VkRGVjb2RlciA9IHJlcXVpcmUoJy4vZmxvd2VkLWRlY29kZXInKTtcblxuLyoqXG4gKiBOb2RlUmV3cml0ZXIgVHJhbnNmb3JtIHN0cmVhbS4gVXBkYXRlcyBjb250ZW50IGZvciBhbGwgbm9kZXMgd2l0aCBzcGVjaWZpZWQgbWltZSB0eXBlXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgRGVmaW5lIHRoZSBNaW1lLVR5cGUgdG8gbG9vayBmb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmVhbUFjdGlvbiBGdW5jdGlvbiB0byBydW4gd2l0aCB0aGUgbm9kZSBjb250ZW50XG4gKi9cbmNsYXNzIE5vZGVTdHJlYW1lciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyRnVuYywgc3RyZWFtQWN0aW9uKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuZmlsdGVyRnVuYyA9IGZpbHRlckZ1bmM7XG4gICAgICAgIHRoaXMuc3RyZWFtQWN0aW9uID0gc3RyZWFtQWN0aW9uO1xuXG4gICAgICAgIHRoaXMuZGVjb2RlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbkNvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGludWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnByb2Nlc3NJbmNvbWluZyhkYXRhLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmRlY29kZXIpIHtcbiAgICAgICAgICAgIC8vIGVtaXQgYW4gZW1wdHkgbm9kZSBqdXN0IGluIGNhc2UgdGhlcmUgaXMgcGVuZGluZyBkYXRhIHRvIGVuZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0luY29taW5nKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ25vbmUnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzSW5jb21pbmcoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZGVjb2RlciAmJiBkYXRhLnR5cGUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gZGF0YSB0byBwYXJzZVxuICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRlY29kZXIud3JpdGUoZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVyLm9uY2UoJ2RyYWluJywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlY29kZXIgJiYgZGF0YS50eXBlICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIHN0b3AgZGVjb2RpbmcuXG4gICAgICAgICAgICAvLyB3ZSBjYW4gbm90IHByb2Nlc3MgdGhlIGN1cnJlbnQgZGF0YSBjaHVuayBhcyB3ZSBuZWVkIHRvIHdhaXQgdW50aWxcbiAgICAgICAgICAgIC8vIHRoZSBwYXJzZWQgZGF0YSBpcyBjb21wbGV0ZWx5IHByb2Nlc3NlZCwgc28gd2Ugc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlXG4gICAgICAgICAgICAvLyBjb250aW51ZSBjYWxsYmFja1xuXG4gICAgICAgICAgICBsZXQgZG9Db250aW51ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5Db250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0luY29taW5nKGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGRvQ29udGludWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlID0gKCkgPT4gZG9Db250aW51ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVyLmVuZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ25vZGUnICYmIHRoaXMuZmlsdGVyRnVuYyhkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgLy8gZm91bmQgbWF0Y2hpbmcgbm9kZSwgY3JlYXRlIG5ldyBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ25vZGUnLCB0aGlzLmNyZWF0ZURlY29kZXIoZGF0YSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVhZGFibGUgJiYgZGF0YS50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBkYXRhLCBqdXN0IHBhc3MgaXQgb3ZlciB0byB0aGUgam9pbmVyXG4gICAgICAgICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWNvZGVyKG5vZGUpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbm9kZS5nZXREZWNvZGVyKCk7XG5cbiAgICAgICAgbGV0IGRlY29kZXIgPSB0aGlzLmRlY29kZXI7XG4gICAgICAgIGRlY29kZXIuJHJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoL150ZXh0XFwvLy50ZXN0KG5vZGUuY29udGVudFR5cGUpICYmIG5vZGUuZmxvd2VkKSB7XG4gICAgICAgICAgICBsZXQgZmxvd0RlY29kZXIgPSBkZWNvZGVyO1xuICAgICAgICAgICAgZGVjb2RlciA9IG5ldyBGbG93ZWREZWNvZGVyKHtcbiAgICAgICAgICAgICAgICBkZWxTcDogbm9kZS5kZWxTcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmbG93RGVjb2Rlci5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGRlY29kZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmbG93RGVjb2Rlci5waXBlKGRlY29kZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBkZWNvZGVyLFxuICAgICAgICAgICAgZG9uZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb250aW51ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgb25jZSBpbnB1dCBzdHJlYW0gaXMgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgYmVmb3JlIGlucHV0IHN0cmVhbSBpcyBwcm9jZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5Db250aW51ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlU3RyZWFtZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-streamer.js\n");

/***/ })

};
;