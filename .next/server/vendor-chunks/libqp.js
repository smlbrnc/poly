"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/libqp";
exports.ids = ["vendor-chunks/libqp"];
exports.modules = {

/***/ "(rsc)/./node_modules/libqp/lib/libqp.js":
/*!*****************************************!*\
  !*** ./node_modules/libqp/lib/libqp.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-useless-escape: 0 */\n\n\n\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst stream = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst Transform = stream.Transform;\n\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = Buffer.from(buffer, 'utf-8');\n    }\n\n    // usable characters that do not need encoding\n    let ranges = [\n        // https://tools.ietf.org/html/rfc2045#section-6.7\n        [0x09], // <TAB>\n        [0x0a], // <LF>\n        [0x0d], // <CR>\n        [0x20, 0x3c], // <SP>!\"#$%&'()*+,-./0123456789:;\n        [0x3e, 0x7e] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    let result = '';\n    let ord;\n\n    for (let i = 0, len = buffer.length; i < len; i++) {\n        ord = buffer[i];\n        // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n            result += String.fromCharCode(ord);\n            continue;\n        }\n        result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n    }\n\n    return result;\n}\n\n/**\n * Decodes a Quoted-Printable encoded string to a Buffer object\n *\n * @param {String} str Quoted-Printable encoded string\n * @returns {Buffer} Decoded value\n */\nfunction decode(str) {\n    str = (str || '')\n        .toString()\n        // remove invalid whitespace from the end of lines\n        .replace(/[\\t ]+$/gm, '')\n        // remove soft line breaks\n        .replace(/\\=(?:\\r?\\n|$)/g, '');\n\n    let encodedBytesCount = (str.match(/\\=[\\da-fA-F]{2}/g) || []).length,\n        bufferLength = str.length - encodedBytesCount * 2,\n        chr,\n        hex,\n        buffer = Buffer.alloc(bufferLength),\n        bufferPos = 0;\n\n    for (let i = 0, len = str.length; i < len; i++) {\n        chr = str.charAt(i);\n        if (chr === '=' && (hex = str.substr(i + 1, 2)) && /[\\da-fA-F]{2}/.test(hex)) {\n            buffer[bufferPos++] = parseInt(hex, 16);\n            i += 2;\n            continue;\n        }\n        buffer[bufferPos++] = chr.charCodeAt(0);\n    }\n\n    return buffer;\n}\n\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    let pos = 0,\n        len = str.length,\n        match,\n        code,\n        line,\n        lineMargin = Math.floor(lineLength / 3),\n        result = '';\n\n    // insert soft linebreaks where needed\n    while (pos < len) {\n        line = str.substr(pos, lineLength);\n        if ((match = line.match(/\\r\\n/))) {\n            line = line.substr(0, match.index + match[0].length);\n            result += line;\n            pos += line.length;\n            continue;\n        }\n\n        if (line.substr(-1) === '\\n') {\n            // nothing to change here\n            result += line;\n            pos += line.length;\n            continue;\n        } else if ((match = line.substr(-lineMargin).match(/\\n.*?$/))) {\n            // truncate to nearest line break\n            line = line.substr(0, line.length - (match[0].length - 1));\n            result += line;\n            pos += line.length;\n            continue;\n        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t\\.,!\\?][^ \\t\\.,!\\?]*$/))) {\n            // truncate to nearest space\n            line = line.substr(0, line.length - (match[0].length - 1));\n        } else if (line.match(/\\=[\\da-f]{0,2}$/i)) {\n            // push incomplete encoding sequences to the next line\n            if ((match = line.match(/\\=[\\da-f]{0,1}$/i))) {\n                line = line.substr(0, line.length - match[0].length);\n            }\n\n            // ensure that utf-8 sequences are not split\n            while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/\\=[\\da-f]{2}$/gi))) {\n                code = parseInt(match[0].substr(1, 2), 16);\n                if (code < 128) {\n                    break;\n                }\n\n                line = line.substr(0, line.length - 3);\n\n                if (code >= 0xc0) {\n                    break;\n                }\n            }\n        }\n\n        if (pos + line.length < len && line.substr(-1) !== '\\n') {\n            if (line.length === lineLength && line.match(/\\=[\\da-f]{2}$/i)) {\n                line = line.substr(0, line.length - 3);\n            } else if (line.length === lineLength) {\n                line = line.substr(0, line.length - 1);\n            }\n            pos += line.length;\n            line += '=\\r\\n';\n        } else {\n            pos += line.length;\n        }\n\n        result += line;\n    }\n\n    return result;\n}\n\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\nfunction checkRanges(nr, ranges) {\n    for (let i = ranges.length - 1; i >= 0; i--) {\n        if (!ranges[i].length) {\n            continue;\n        }\n        if (ranges[i].length === 1 && nr === ranges[i][0]) {\n            return true;\n        }\n        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */\nclass Encoder extends Transform {\n    constructor(options) {\n        super();\n\n        // init Transform\n        this.options = options || {};\n\n        if (this.options.lineLength !== false) {\n            this.options.lineLength = this.options.lineLength || 76;\n        }\n\n        this._curLine = '';\n\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n\n        Transform.call(this, this.options);\n    }\n\n    _transform(chunk, encoding, done) {\n        let qp;\n\n        if (encoding !== 'buffer') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        this.inputBytes += chunk.length;\n\n        if (this.options.lineLength) {\n            qp = this._curLine + encode(chunk);\n            qp = wrap(qp, this.options.lineLength);\n            qp = qp.replace(/(^|\\n)([^\\n]*)$/, (match, lineBreak, lastLine) => {\n                this._curLine = lastLine;\n                return lineBreak;\n            });\n\n            if (qp) {\n                this.outputBytes += qp.length;\n                this.push(qp);\n            }\n        } else {\n            qp = encode(chunk);\n            this.outputBytes += qp.length;\n            this.push(qp, 'ascii');\n        }\n\n        done();\n    }\n\n    _flush(done) {\n        if (this._curLine) {\n            this.outputBytes += this._curLine.length;\n            this.push(this._curLine, 'ascii');\n        }\n        done();\n    }\n}\n\n/**\n * Creates a transform stream for decoding Quoted-Printable encoded strings\n * The input is not actually processed as a stream but concatted and processed as a single input\n *\n * @constructor\n * @param {Object} options Stream options\n */\nclass Decoder extends Transform {\n    constructor(options) {\n        options = options || {};\n        super(options);\n\n        // init Transform\n        this.options = options;\n        this._curLine = '';\n\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n\n        this.qpChunks = [];\n    }\n\n    _transform(chunk, encoding, done) {\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        this.qpChunks.push(chunk);\n        this.inputBytes += chunk.length;\n\n        done();\n    }\n\n    _flush(done) {\n        if (this.inputBytes) {\n            let buf = decode(Buffer.concat(this.qpChunks, this.inputBytes).toString());\n            this.outputBytes += buf.length;\n            this.push(buf);\n        }\n\n        done();\n    }\n}\n\n// expose to the world\nmodule.exports = {\n    encode,\n    decode,\n    wrap,\n    Encoder,\n    Decoder\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlicXAvbGliL2xpYnFwLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVhOztBQUViLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0EsdUVBQXVFLEVBQUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVUsK0JBQStCLElBQUk7QUFDN0M7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRDtBQUNBOztBQUVBO0FBQ0EsMkZBQTJGLEVBQUUsRUFBRSxJQUFJLHVDQUF1QyxFQUFFO0FBQzVJO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9seW1hcmtldC1hcmJpdHJhZ2Utbm9kZS8uL25vZGVfbW9kdWxlcy9saWJxcC9saWIvbGlicXAuanM/NWJhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdXNlbGVzcy1lc2NhcGU6IDAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKTtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJyk7XG5jb25zdCBUcmFuc2Zvcm0gPSBzdHJlYW0uVHJhbnNmb3JtO1xuXG4vKipcbiAqIEVuY29kZXMgYSBCdWZmZXIgaW50byBhIFF1b3RlZC1QcmludGFibGUgZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBRdW90ZWQtUHJpbnRhYmxlIGVuY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShidWZmZXIpIHtcbiAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyLCAndXRmLTgnKTtcbiAgICB9XG5cbiAgICAvLyB1c2FibGUgY2hhcmFjdGVycyB0aGF0IGRvIG5vdCBuZWVkIGVuY29kaW5nXG4gICAgbGV0IHJhbmdlcyA9IFtcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIwNDUjc2VjdGlvbi02LjdcbiAgICAgICAgWzB4MDldLCAvLyA8VEFCPlxuICAgICAgICBbMHgwYV0sIC8vIDxMRj5cbiAgICAgICAgWzB4MGRdLCAvLyA8Q1I+XG4gICAgICAgIFsweDIwLCAweDNjXSwgLy8gPFNQPiFcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5OjtcbiAgICAgICAgWzB4M2UsIDB4N2VdIC8vID4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9XG4gICAgXTtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgbGV0IG9yZDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBidWZmZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb3JkID0gYnVmZmVyW2ldO1xuICAgICAgICAvLyBpZiB0aGUgY2hhciBpcyBpbiBhbGxvd2VkIHJhbmdlLCB0aGVuIGtlZXAgYXMgaXMsIHVubGVzcyBpdCBpcyBhIHdzIGluIHRoZSBlbmQgb2YgYSBsaW5lXG4gICAgICAgIGlmIChjaGVja1JhbmdlcyhvcmQsIHJhbmdlcykgJiYgISgob3JkID09PSAweDIwIHx8IG9yZCA9PT0gMHgwOSkgJiYgKGkgPT09IGxlbiAtIDEgfHwgYnVmZmVyW2kgKyAxXSA9PT0gMHgwYSB8fCBidWZmZXJbaSArIDFdID09PSAweDBkKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG9yZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJz0nICsgKG9yZCA8IDB4MTAgPyAnMCcgOiAnJykgKyBvcmQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgUXVvdGVkLVByaW50YWJsZSBlbmNvZGVkIHN0cmluZyB0byBhIEJ1ZmZlciBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFF1b3RlZC1QcmludGFibGUgZW5jb2RlZCBzdHJpbmdcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IERlY29kZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgIHN0ciA9IChzdHIgfHwgJycpXG4gICAgICAgIC50b1N0cmluZygpXG4gICAgICAgIC8vIHJlbW92ZSBpbnZhbGlkIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGxpbmVzXG4gICAgICAgIC5yZXBsYWNlKC9bXFx0IF0rJC9nbSwgJycpXG4gICAgICAgIC8vIHJlbW92ZSBzb2Z0IGxpbmUgYnJlYWtzXG4gICAgICAgIC5yZXBsYWNlKC9cXD0oPzpcXHI/XFxufCQpL2csICcnKTtcblxuICAgIGxldCBlbmNvZGVkQnl0ZXNDb3VudCA9IChzdHIubWF0Y2goL1xcPVtcXGRhLWZBLUZdezJ9L2cpIHx8IFtdKS5sZW5ndGgsXG4gICAgICAgIGJ1ZmZlckxlbmd0aCA9IHN0ci5sZW5ndGggLSBlbmNvZGVkQnl0ZXNDb3VudCAqIDIsXG4gICAgICAgIGNocixcbiAgICAgICAgaGV4LFxuICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2MoYnVmZmVyTGVuZ3RoKSxcbiAgICAgICAgYnVmZmVyUG9zID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2hyID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNociA9PT0gJz0nICYmIChoZXggPSBzdHIuc3Vic3RyKGkgKyAxLCAyKSkgJiYgL1tcXGRhLWZBLUZdezJ9Ly50ZXN0KGhleCkpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltidWZmZXJQb3MrK10gPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlcltidWZmZXJQb3MrK10gPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKipcbiAqIEFkZHMgc29mdCBsaW5lIGJyZWFrcyB0byBhIFF1b3RlZC1QcmludGFibGUgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBRdW90ZWQtUHJpbnRhYmxlIGVuY29kZWQgc3RyaW5nIHRoYXQgbWlnaHQgbmVlZCBsaW5lIHdyYXBwaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbmVMZW5ndGg9NzZdIE1heGltdW0gYWxsb3dlZCBsZW5ndGggZm9yIGEgbGluZVxuICogQHJldHVybnMge1N0cmluZ30gU29mdC13cmFwcGVkIFF1b3RlZC1QcmludGFibGUgZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gd3JhcChzdHIsIGxpbmVMZW5ndGgpIHtcbiAgICBzdHIgPSAoc3RyIHx8ICcnKS50b1N0cmluZygpO1xuICAgIGxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoIHx8IDc2O1xuXG4gICAgaWYgKHN0ci5sZW5ndGggPD0gbGluZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGxldCBwb3MgPSAwLFxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgY29kZSxcbiAgICAgICAgbGluZSxcbiAgICAgICAgbGluZU1hcmdpbiA9IE1hdGguZmxvb3IobGluZUxlbmd0aCAvIDMpLFxuICAgICAgICByZXN1bHQgPSAnJztcblxuICAgIC8vIGluc2VydCBzb2Z0IGxpbmVicmVha3Mgd2hlcmUgbmVlZGVkXG4gICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICBsaW5lID0gc3RyLnN1YnN0cihwb3MsIGxpbmVMZW5ndGgpO1xuICAgICAgICBpZiAoKG1hdGNoID0gbGluZS5tYXRjaCgvXFxyXFxuLykpKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIoMCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmU7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5lLnN1YnN0cigtMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGNoYW5nZSBoZXJlXG4gICAgICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGxpbmUuc3Vic3RyKC1saW5lTWFyZ2luKS5tYXRjaCgvXFxuLio/JC8pKSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdG8gbmVhcmVzdCBsaW5lIGJyZWFrXG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIoMCwgbGluZS5sZW5ndGggLSAobWF0Y2hbMF0ubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmU7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLmxlbmd0aCA+IGxpbmVMZW5ndGggLSBsaW5lTWFyZ2luICYmIChtYXRjaCA9IGxpbmUuc3Vic3RyKC1saW5lTWFyZ2luKS5tYXRjaCgvWyBcXHRcXC4sIVxcP11bXiBcXHRcXC4sIVxcP10qJC8pKSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdG8gbmVhcmVzdCBzcGFjZVxuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gKG1hdGNoWzBdLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKC9cXD1bXFxkYS1mXXswLDJ9JC9pKSkge1xuICAgICAgICAgICAgLy8gcHVzaCBpbmNvbXBsZXRlIGVuY29kaW5nIHNlcXVlbmNlcyB0byB0aGUgbmV4dCBsaW5lXG4gICAgICAgICAgICBpZiAoKG1hdGNoID0gbGluZS5tYXRjaCgvXFw9W1xcZGEtZl17MCwxfSQvaSkpKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgdXRmLTggc2VxdWVuY2VzIGFyZSBub3Qgc3BsaXRcbiAgICAgICAgICAgIHdoaWxlIChsaW5lLmxlbmd0aCA+IDMgJiYgbGluZS5sZW5ndGggPCBsZW4gLSBwb3MgJiYgIWxpbmUubWF0Y2goL14oPzo9W1xcZGEtZl17Mn0pezEsNH0kL2kpICYmIChtYXRjaCA9IGxpbmUubWF0Y2goL1xcPVtcXGRhLWZdezJ9JC9naSkpKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IHBhcnNlSW50KG1hdGNoWzBdLnN1YnN0cigxLCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gMHhjMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zICsgbGluZS5sZW5ndGggPCBsZW4gJiYgbGluZS5zdWJzdHIoLTEpICE9PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSBsaW5lTGVuZ3RoICYmIGxpbmUubWF0Y2goL1xcPVtcXGRhLWZdezJ9JC9pKSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmxlbmd0aCA9PT0gbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgbGluZSArPSAnPVxcclxcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhIG51bWJlciBpcyBpbnNpZGUgcHJvdmlkZWQgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5yIE51bWJlciB0byBjaGVjayBmb3JcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlcyBBbiBBcnJheSBvZiBhbGxvd2VkIHZhbHVlc1xuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIHdhcyBmb3VuZCBpbnNpZGUgYWxsb3dlZCByYW5nZXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBjaGVja1JhbmdlcyhuciwgcmFuZ2VzKSB7XG4gICAgZm9yIChsZXQgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoIXJhbmdlc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZXNbaV0ubGVuZ3RoID09PSAxICYmIG5yID09PSByYW5nZXNbaV1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZXNbaV0ubGVuZ3RoID09PSAyICYmIG5yID49IHJhbmdlc1tpXVswXSAmJiBuciA8PSByYW5nZXNbaV1bMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSBmb3IgZW5jb2RpbmcgZGF0YSB0byBRdW90ZWQtUHJpbnRhYmxlIGVuY29kaW5nXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTdHJlYW0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbmVMZW5ndGg9NzZdIE1heGltdW0gbGVuZ2h0IGZvciBsaW5lcywgc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgd3JhcHBpbmdcbiAqL1xuY2xhc3MgRW5jb2RlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIGluaXQgVHJhbnNmb3JtXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxpbmVMZW5ndGggPSB0aGlzLm9wdGlvbnMubGluZUxlbmd0aCB8fCA3NjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1ckxpbmUgPSAnJztcblxuICAgICAgICB0aGlzLmlucHV0Qnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLm91dHB1dEJ5dGVzID0gMDtcblxuICAgICAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICAgIGxldCBxcDtcblxuICAgICAgICBpZiAoZW5jb2RpbmcgIT09ICdidWZmZXInKSB7XG4gICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlucHV0Qnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGluZUxlbmd0aCkge1xuICAgICAgICAgICAgcXAgPSB0aGlzLl9jdXJMaW5lICsgZW5jb2RlKGNodW5rKTtcbiAgICAgICAgICAgIHFwID0gd3JhcChxcCwgdGhpcy5vcHRpb25zLmxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcXAgPSBxcC5yZXBsYWNlKC8oXnxcXG4pKFteXFxuXSopJC8sIChtYXRjaCwgbGluZUJyZWFrLCBsYXN0TGluZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1ckxpbmUgPSBsYXN0TGluZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZUJyZWFrO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChxcCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgKz0gcXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChxcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxcCA9IGVuY29kZShjaHVuayk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IHFwLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucHVzaChxcCwgJ2FzY2lpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGRvbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1ckxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgKz0gdGhpcy5fY3VyTGluZS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5fY3VyTGluZSwgJ2FzY2lpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSBmb3IgZGVjb2RpbmcgUXVvdGVkLVByaW50YWJsZSBlbmNvZGVkIHN0cmluZ3NcbiAqIFRoZSBpbnB1dCBpcyBub3QgYWN0dWFsbHkgcHJvY2Vzc2VkIGFzIGEgc3RyZWFtIGJ1dCBjb25jYXR0ZWQgYW5kIHByb2Nlc3NlZCBhcyBhIHNpbmdsZSBpbnB1dFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU3RyZWFtIG9wdGlvbnNcbiAqL1xuY2xhc3MgRGVjb2RlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gaW5pdCBUcmFuc2Zvcm1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fY3VyTGluZSA9ICcnO1xuXG4gICAgICAgIHRoaXMuaW5wdXRCeXRlcyA9IDA7XG4gICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgPSAwO1xuXG4gICAgICAgIHRoaXMucXBDaHVua3MgPSBbXTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICBpZiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5xcENodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5pbnB1dEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGRvbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRCeXRlcykge1xuICAgICAgICAgICAgbGV0IGJ1ZiA9IGRlY29kZShCdWZmZXIuY29uY2F0KHRoaXMucXBDaHVua3MsIHRoaXMuaW5wdXRCeXRlcykudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2goYnVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG59XG5cbi8vIGV4cG9zZSB0byB0aGUgd29ybGRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZSxcbiAgICBkZWNvZGUsXG4gICAgd3JhcCxcbiAgICBFbmNvZGVyLFxuICAgIERlY29kZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libqp/lib/libqp.js\n");

/***/ })

};
;