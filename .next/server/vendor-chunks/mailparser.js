"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mailparser";
exports.ids = ["vendor-chunks/mailparser"];
exports.modules = {

/***/ "(rsc)/./node_modules/mailparser/index.js":
/*!******************************************!*\
  !*** ./node_modules/mailparser/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MailParser = __webpack_require__(/*! ./lib/mail-parser */ \"(rsc)/./node_modules/mailparser/lib/mail-parser.js\");\nconst simpleParser = __webpack_require__(/*! ./lib/simple-parser */ \"(rsc)/./node_modules/mailparser/lib/simple-parser.js\");\n\nmodule.exports = {\n    MailParser,\n    simpleParser\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsaUZBQXFCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvbHltYXJrZXQtYXJiaXRyYWdlLW5vZGUvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9pbmRleC5qcz8wN2RhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWFpbFBhcnNlciA9IHJlcXVpcmUoJy4vbGliL21haWwtcGFyc2VyJyk7XG5jb25zdCBzaW1wbGVQYXJzZXIgPSByZXF1aXJlKCcuL2xpYi9zaW1wbGUtcGFyc2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIE1haWxQYXJzZXIsXG4gICAgc2ltcGxlUGFyc2VyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mailparser/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mailparser/lib/mail-parser.js":
/*!****************************************************!*\
  !*** ./node_modules/mailparser/lib/mail-parser.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst mailsplit = __webpack_require__(/*! @zone-eu/mailsplit */ \"(rsc)/./node_modules/@zone-eu/mailsplit/index.js\");\nconst libmime = __webpack_require__(/*! libmime */ \"(rsc)/./node_modules/libmime/lib/libmime.js\");\nconst addressparser = __webpack_require__(/*! nodemailer/lib/addressparser */ \"(rsc)/./node_modules/nodemailer/lib/addressparser/index.js\");\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst Splitter = mailsplit.Splitter;\nconst ChunkedPassthrough = mailsplit.ChunkedPassthrough;\nconst punycode = __webpack_require__(/*! punycode.js */ \"(rsc)/./node_modules/punycode.js/punycode.es6.js\");\nconst FlowedDecoder = __webpack_require__(/*! @zone-eu/mailsplit/lib/flowed-decoder */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js\");\nconst StreamHash = __webpack_require__(/*! ./stream-hash */ \"(rsc)/./node_modules/mailparser/lib/stream-hash.js\");\nconst iconv = __webpack_require__(/*! iconv-lite */ \"(rsc)/./node_modules/iconv-lite/lib/index.js\");\nconst { htmlToText } = __webpack_require__(/*! html-to-text */ \"(rsc)/./node_modules/html-to-text/lib/html-to-text.cjs\");\nconst he = __webpack_require__(/*! he */ \"(rsc)/./node_modules/he/he.js\");\nconst linkify = __webpack_require__(/*! linkify-it */ \"(rsc)/./node_modules/linkify-it/build/index.cjs.js\")();\nconst tlds = __webpack_require__(/*! tlds */ \"(rsc)/./node_modules/tlds/index.json\");\nconst encodingJapanese = __webpack_require__(/*! encoding-japanese */ \"(rsc)/./node_modules/encoding-japanese/src/index.js\");\n\nlinkify\n    .tlds(tlds) // Reload with full tlds list\n    .tlds('onion', true) // Add unofficial `.onion` domain\n    .add('git:', 'http:') // Add `git:` ptotocol as \"alias\"\n    .add('ftp:', null) // Disable `ftp:` ptotocol\n    .set({ fuzzyIP: true, fuzzyLink: true, fuzzyEmail: true });\n\n// twitter linkifier from\n// https://github.com/markdown-it/linkify-it#example-2-add-twitter-mentions-handler\nlinkify.add('@', {\n    validate(text, pos, self) {\n        let tail = text.slice(pos);\n\n        if (!self.re.twitter) {\n            self.re.twitter = new RegExp('^([a-zA-Z0-9_]){1,15}(?!_)(?=$|' + self.re.src_ZPCc + ')');\n        }\n        if (self.re.twitter.test(tail)) {\n            // Linkifier allows punctuation chars before prefix,\n            // but we additionally disable `@` (\"@@mention\" is invalid)\n            if (pos >= 2 && tail[pos - 2] === '@') {\n                return false;\n            }\n            return tail.match(self.re.twitter)[0].length;\n        }\n        return 0;\n    },\n    normalize(match) {\n        match.url = 'https://twitter.com/' + match.url.replace(/^@/, '');\n    }\n});\n\nclass IconvDecoder extends Transform {\n    constructor(Iconv, charset) {\n        super();\n\n        // Iconv throws error on ks_c_5601-1987 when it is mapped to EUC-KR\n        // https://github.com/bnoordhuis/node-iconv/issues/169\n        if (charset.toLowerCase() === 'ks_c_5601-1987') {\n            charset = 'CP949';\n        }\n        this.stream = new Iconv(charset, 'UTF-8//TRANSLIT//IGNORE');\n\n        this.inputEnded = false;\n        this.endCb = false;\n\n        this.stream.on('error', err => this.emit('error', err));\n        this.stream.on('data', chunk => this.push(chunk));\n        this.stream.on('end', () => {\n            this.inputEnded = true;\n            if (typeof this.endCb === 'function') {\n                this.endCb();\n            }\n        });\n    }\n\n    _transform(chunk, encoding, done) {\n        this.stream.write(chunk);\n        done();\n    }\n\n    _flush(done) {\n        this.endCb = done;\n        this.stream.end();\n    }\n}\n\nclass JPDecoder extends Transform {\n    constructor(charset) {\n        super();\n\n        this.charset = charset;\n        this.chunks = [];\n        this.chunklen = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        this.chunks.push(chunk);\n        this.chunklen += chunk.length;\n        done();\n    }\n\n    _flush(done) {\n        let input = Buffer.concat(this.chunks, this.chunklen);\n        try {\n            let output = encodingJapanese.convert(input, {\n                to: 'UNICODE', // to_encoding\n                from: this.charset, // from_encoding\n                type: 'string'\n            });\n            if (typeof output === 'string') {\n                output = Buffer.from(output);\n            }\n            this.push(output);\n        } catch (err) {\n            // keep as is on errors\n            this.push(input);\n        }\n\n        done();\n    }\n}\n\nclass MailParser extends Transform {\n    constructor(config) {\n        super({\n            readableObjectMode: true,\n            writableObjectMode: false\n        });\n\n        this.options = config || {};\n        this.chunkedPassthrough = new ChunkedPassthrough();\n        this.splitter = new Splitter(config);\n\n        this.chunkedPassthrough.pipe(this.splitter);\n\n        this.finished = false;\n        this.waitingEnd = false;\n\n        this.headers = false;\n        this.headerLines = false;\n\n        this.endReceived = false;\n        this.reading = false;\n        this.hasFailed = false;\n\n        this.tree = false;\n        this.curnode = false;\n        this.waitUntilAttachmentEnd = false;\n        this.attachmentCallback = false;\n\n        this.hasHtml = false;\n        this.hasText = false;\n\n        this.text = false;\n        this.html = false;\n        this.textAsHtml = false;\n\n        this.attachmentList = [];\n\n        this.boundaries = [];\n\n        this.textTypes = ['text/plain', 'text/html'].concat(!this.options.keepDeliveryStatus ? 'message/delivery-status' : []);\n\n        this.decoder = this.getDecoder();\n\n        this.chunkedPassthrough.on('error', err => {\n            this.splitter.emit('error', err);\n        });\n\n        this.splitter.on('readable', () => {\n            if (this.reading) {\n                return false;\n            }\n            this.readData();\n        });\n\n        this.splitter.on('end', () => {\n            this.endReceived = true;\n            if (!this.reading) {\n                this.endStream();\n            }\n        });\n\n        this.splitter.on('error', err => {\n            this.hasFailed = true;\n            if (typeof this.waitingEnd === 'function') {\n                return this.waitingEnd(err);\n            }\n            this.emit('error', err);\n        });\n\n        this.libmime = new libmime.Libmime({ Iconv: this.options.Iconv });\n    }\n\n    getDecoder() {\n        if (this.options.Iconv) {\n            const Iconv = this.options.Iconv;\n            // create wrapper\n            return {\n                decodeStream(charset) {\n                    return new IconvDecoder(Iconv, charset);\n                }\n            };\n        } else {\n            return {\n                decodeStream(charset) {\n                    charset = (charset || 'ascii').toString().trim().toLowerCase();\n                    if (/^jis|^iso-?2022-?jp|^EUCJP/i.test(charset)) {\n                        // special case not supported by iconv-lite\n                        return new JPDecoder(charset);\n                    }\n\n                    return iconv.decodeStream(charset);\n                }\n            };\n        }\n    }\n\n    readData() {\n        if (this.hasFailed) {\n            return false;\n        }\n        this.reading = true;\n        let data = this.splitter.read();\n        if (data === null) {\n            this.reading = false;\n            if (this.endReceived) {\n                this.endStream();\n            }\n            return;\n        }\n\n        this.processChunk(data, err => {\n            if (err) {\n                if (typeof this.waitingEnd === 'function') {\n                    return this.waitingEnd(err);\n                }\n                return this.emit('error', err);\n            }\n            setImmediate(() => this.readData());\n        });\n    }\n\n    endStream() {\n        this.finished = true;\n\n        if (this.curnode && this.curnode.decoder) {\n            this.curnode.decoder.end();\n        }\n        if (typeof this.waitingEnd === 'function') {\n            this.waitingEnd();\n        }\n    }\n\n    _transform(chunk, encoding, done) {\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        if (this.chunkedPassthrough.write(chunk) === false) {\n            return this.chunkedPassthrough.once('drain', () => {\n                done();\n            });\n        } else {\n            return done();\n        }\n    }\n\n    _flush(done) {\n        setImmediate(() => this.chunkedPassthrough.end());\n        if (this.finished) {\n            return this.cleanup(done);\n        }\n        this.waitingEnd = () => {\n            this.cleanup(() => {\n                done();\n            });\n        };\n    }\n\n    cleanup(done) {\n        let finish = () => {\n            try {\n                let t = this.getTextContent();\n                this.push(t);\n            } catch (err) {\n                return this.emit('error', err);\n            }\n\n            done();\n        };\n\n        if (this.curnode && this.curnode.decoder && this.curnode.decoder.readable && !this.decoderEnded) {\n            (this.curnode.contentStream || this.curnode.decoder).once('end', () => {\n                finish();\n            });\n            this.curnode.decoder.end();\n        } else {\n            setImmediate(() => {\n                finish();\n            });\n        }\n    }\n\n    processHeaders(lines) {\n        let headers = new Map();\n        (lines || []).forEach(line => {\n            let key = line.key;\n            let value = ((this.libmime.decodeHeader(line.line) || {}).value || '').toString().trim();\n            value = Buffer.from(value, 'binary').toString();\n            switch (key) {\n                case 'content-type':\n                case 'content-disposition':\n                case 'dkim-signature':\n                    value = this.libmime.parseHeaderValue(value);\n                    if (value.value) {\n                        value.value = this.libmime.decodeWords(value.value);\n                    }\n                    Object.keys((value && value.params) || {}).forEach(key => {\n                        try {\n                            value.params[key] = this.libmime.decodeWords(value.params[key]);\n                        } catch (E) {\n                            // ignore, keep as is\n                        }\n                    });\n                    break;\n                case 'date': {\n                    let dateValue = new Date(value);\n                    if (isNaN(dateValue)) {\n                        // date parsing failed :S\n                        dateValue = new Date();\n                    }\n                    value = dateValue;\n                    break;\n                }\n                case 'subject':\n                    try {\n                        value = this.libmime.decodeWords(value);\n                    } catch (E) {\n                        // ignore, keep as is\n                    }\n                    break;\n                case 'references':\n                    try {\n                        value = this.libmime.decodeWords(value);\n                    } catch (E) {\n                        // ignore\n                    }\n                    value = value.split(/\\s+/).map(this.ensureMessageIDFormat);\n                    break;\n                case 'message-id':\n                case 'in-reply-to':\n                    try {\n                        value = this.libmime.decodeWords(value);\n                    } catch (E) {\n                        // ignore\n                    }\n                    value = this.ensureMessageIDFormat(value);\n                    break;\n                case 'priority':\n                case 'x-priority':\n                case 'x-msmail-priority':\n                case 'importance':\n                    key = 'priority';\n                    value = this.parsePriority(value);\n                    break;\n                case 'from':\n                case 'to':\n                case 'cc':\n                case 'bcc':\n                case 'sender':\n                case 'reply-to':\n                case 'delivered-to':\n                case 'return-path':\n                case 'disposition-notification-to':\n                    value = addressparser(value);\n                    this.decodeAddresses(value);\n                    value = {\n                        value,\n                        html: this.getAddressesHTML(value),\n                        text: this.getAddressesText(value)\n                    };\n                    break;\n            }\n\n            // handle list-* keys\n            if (key.substr(0, 5) === 'list-') {\n                value = this.parseListHeader(key.substr(5), value);\n                key = 'list';\n            }\n\n            if (value) {\n                if (!headers.has(key)) {\n                    headers.set(key, [].concat(value || []));\n                } else if (Array.isArray(value)) {\n                    headers.set(key, headers.get(key).concat(value));\n                } else {\n                    headers.get(key).push(value);\n                }\n            }\n        });\n\n        // keep only the first value\n        let singleKeys = [\n            'message-id',\n            'content-id',\n            'from',\n            'sender',\n            'in-reply-to',\n            'reply-to',\n            'subject',\n            'date',\n            'content-disposition',\n            'content-type',\n            'content-transfer-encoding',\n            'priority',\n            'mime-version',\n            'content-description',\n            'precedence',\n            'errors-to',\n            'disposition-notification-to'\n        ];\n\n        headers.forEach((value, key) => {\n            if (Array.isArray(value)) {\n                if (singleKeys.includes(key) && value.length) {\n                    headers.set(key, value[value.length - 1]);\n                } else if (value.length === 1) {\n                    headers.set(key, value[0]);\n                }\n            }\n\n            if (key === 'list') {\n                // normalize List-* headers\n                let listValue = {};\n                [].concat(value || []).forEach(val => {\n                    Object.keys(val || {}).forEach(listKey => {\n                        listValue[listKey] = val[listKey];\n                    });\n                });\n                headers.set(key, listValue);\n            }\n        });\n\n        return headers;\n    }\n\n    parseListHeader(key, value) {\n        let addresses = addressparser(value);\n        let response = {};\n        let data = addresses\n            .map(address => {\n                if (/^https?:/i.test(address.name)) {\n                    response.url = address.name;\n                } else if (address.name) {\n                    response.name = address.name;\n                }\n                if (/^mailto:/.test(address.address)) {\n                    response.mail = address.address.substr(7);\n                } else if (address.address && address.address.indexOf('@') < 0) {\n                    response.id = address.address;\n                } else if (address.address) {\n                    response.mail = address.address;\n                }\n                if (Object.keys(response).length) {\n                    return response;\n                }\n                return false;\n            })\n            .filter(address => address);\n        if (data.length) {\n            return {\n                [key]: response\n            };\n        }\n        return false;\n    }\n\n    parsePriority(value) {\n        value = value.toLowerCase().trim();\n        if (!isNaN(parseInt(value, 10))) {\n            // support \"X-Priority: 1 (Highest)\"\n            value = parseInt(value, 10) || 0;\n            if (value === 3) {\n                return 'normal';\n            } else if (value > 3) {\n                return 'low';\n            } else {\n                return 'high';\n            }\n        } else {\n            switch (value) {\n                case 'non-urgent':\n                case 'low':\n                    return 'low';\n                case 'urgent':\n                case 'high':\n                    return 'high';\n            }\n        }\n        return 'normal';\n    }\n\n    ensureMessageIDFormat(value) {\n        if (!value.length) {\n            return false;\n        }\n\n        if (value.charAt(0) !== '<') {\n            value = '<' + value;\n        }\n\n        if (value.charAt(value.length - 1) !== '>') {\n            value += '>';\n        }\n\n        return value;\n    }\n\n    decodeAddresses(addresses) {\n        let processedAddress = new WeakSet();\n        for (let i = 0; i < addresses.length; i++) {\n            let address = addresses[i];\n            address.name = (address.name || '').toString().trim();\n\n            if (!address.address && /^(=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)(\\s*=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)*$/.test(address.name) && !processedAddress.has(address)) {\n                let parsed = addressparser(this.libmime.decodeWords(address.name));\n                if (parsed.length) {\n                    parsed.forEach(entry => {\n                        processedAddress.add(entry);\n                        addresses.push(entry);\n                    });\n                }\n\n                // remove current element\n                addresses.splice(i, 1);\n                i--;\n                continue;\n            }\n\n            if (address.name) {\n                try {\n                    address.name = this.libmime.decodeWords(address.name);\n                } catch (E) {\n                    //ignore, keep as is\n                }\n            }\n            if (/@xn--/.test(address.address)) {\n                try {\n                    address.address =\n                        address.address.substr(0, address.address.lastIndexOf('@') + 1) +\n                        punycode.toUnicode(address.address.substr(address.address.lastIndexOf('@') + 1));\n                } catch (E) {\n                    // Not a valid punycode string; keep as is\n                }\n            }\n            if (address.group) {\n                this.decodeAddresses(address.group);\n            }\n        }\n    }\n\n    createNode(node) {\n        let contentType = node.contentType;\n        let disposition = node.disposition;\n        let encoding = node.encoding;\n        let charset = node.charset;\n\n        if (!contentType && node.root) {\n            contentType = 'text/plain';\n        }\n\n        let newNode = {\n            node,\n            headerLines: node.headers.lines,\n            headers: this.processHeaders(node.headers.getList()),\n            contentType,\n            children: []\n        };\n\n        if (!/^multipart\\//i.test(contentType)) {\n            if (disposition && !['attachment', 'inline'].includes(disposition)) {\n                disposition = 'attachment';\n            }\n\n            if (!disposition && !this.textTypes.includes(contentType)) {\n                newNode.disposition = 'attachment';\n            } else {\n                newNode.disposition = disposition || 'inline';\n            }\n\n            newNode.isAttachment = !this.textTypes.includes(contentType) || newNode.disposition !== 'inline';\n\n            newNode.encoding = ['quoted-printable', 'base64'].includes(encoding) ? encoding : 'binary';\n\n            if (charset) {\n                newNode.charset = charset;\n            }\n\n            let decoder = node.getDecoder();\n            decoder.on('end', () => {\n                this.decoderEnded = true;\n            });\n            newNode.decoder = decoder;\n        }\n\n        if (node.root) {\n            this.headers = newNode.headers;\n            this.headerLines = newNode.headerLines;\n        }\n\n        // find location in tree\n\n        if (!this.tree) {\n            newNode.root = true;\n            this.curnode = this.tree = newNode;\n            return newNode;\n        }\n\n        // immediate child of root node\n        if (!this.curnode.parent) {\n            newNode.parent = this.curnode;\n            this.curnode.children.push(newNode);\n            this.curnode = newNode;\n            return newNode;\n        }\n\n        // siblings\n        if (this.curnode.parent.node === node.parentNode) {\n            newNode.parent = this.curnode.parent;\n            this.curnode.parent.children.push(newNode);\n            this.curnode = newNode;\n            return newNode;\n        }\n\n        // first child\n        if (this.curnode.node === node.parentNode) {\n            newNode.parent = this.curnode;\n            this.curnode.children.push(newNode);\n            this.curnode = newNode;\n            return newNode;\n        }\n\n        // move up\n        let parentNode = this.curnode;\n        while ((parentNode = parentNode.parent)) {\n            if (parentNode.node === node.parentNode) {\n                newNode.parent = parentNode;\n                parentNode.children.push(newNode);\n                this.curnode = newNode;\n                return newNode;\n            }\n        }\n\n        // should never happen, can't detect parent\n        this.curnode = newNode;\n        return newNode;\n    }\n\n    getTextContent() {\n        let text = [];\n        let html = [];\n        let processNode = (alternative, level, node) => {\n            if (node.showMeta) {\n                let meta = ['From', 'Subject', 'Date', 'To', 'Cc', 'Bcc']\n                    .map(fkey => {\n                        let key = fkey.toLowerCase();\n                        if (!node.headers.has(key)) {\n                            return false;\n                        }\n                        let value = node.headers.get(key);\n                        if (!value) {\n                            return false;\n                        }\n                        return {\n                            key: fkey,\n                            value: Array.isArray(value) ? value[value.length - 1] : value\n                        };\n                    })\n                    .filter(entry => entry);\n                if (this.hasHtml) {\n                    html.push(\n                        '<table class=\"mp_head\">' +\n                            meta\n                                .map(entry => {\n                                    let value = entry.value;\n                                    switch (entry.key) {\n                                        case 'From':\n                                        case 'To':\n                                        case 'Cc':\n                                        case 'Bcc':\n                                            value = value.html;\n                                            break;\n                                        case 'Date':\n                                            value = this.options.formatDateString ? this.options.formatDateString(value) : value.toUTCString();\n                                            break;\n                                        case 'Subject':\n                                            value = '<strong>' + he.encode(value) + '</strong>';\n                                            break;\n                                        default:\n                                            value = he.encode(value);\n                                    }\n\n                                    return '<tr><td class=\"mp_head_key\">' + he.encode(entry.key) + ':</td><td class=\"mp_head_value\">' + value + '<td></tr>';\n                                })\n                                .join('\\n') +\n                            '<table>'\n                    );\n                }\n                if (this.hasText) {\n                    text.push(\n                        '\\n' +\n                            meta\n                                .map(entry => {\n                                    let value = entry.value;\n                                    switch (entry.key) {\n                                        case 'From':\n                                        case 'To':\n                                        case 'Cc':\n                                        case 'Bcc':\n                                            value = value.text;\n                                            break;\n                                        case 'Date':\n                                            value = this.options.formatDateString ? this.options.formatDateString(value) : value.toUTCString();\n                                            break;\n                                    }\n                                    return entry.key + ': ' + value;\n                                })\n                                .join('\\n') +\n                            '\\n'\n                    );\n                }\n            }\n            if (node.textContent) {\n                if (node.contentType === 'text/plain') {\n                    text.push(node.textContent);\n                    if (!alternative && this.hasHtml) {\n                        html.push(this.textToHtml(node.textContent));\n                    }\n                } else if (node.contentType === 'message/delivery-status' && !this.options.keepDeliveryStatus) {\n                    text.push(node.textContent);\n                    if (!alternative && this.hasHtml) {\n                        html.push(this.textToHtml(node.textContent));\n                    }\n                } else if (node.contentType === 'text/html') {\n                    let failedToParseHtml = false;\n                    if ((!alternative && this.hasText) || (node.root && !this.hasText)) {\n                        if (this.options.skipHtmlToText) {\n                            text.push('');\n                        } else if (node.textContent.length > this.options.maxHtmlLengthToParse) {\n                            this.emit('error', new Error(`HTML too long for parsing ${node.textContent.length} bytes`));\n                            text.push('Invalid HTML content (too long)');\n                            failedToParseHtml = true;\n                        } else {\n                            try {\n                                text.push(htmlToText(node.textContent));\n                            } catch (err) {\n                                this.emit('error', new Error('Failed to parse HTML'));\n                                text.push('Invalid HTML content');\n                                failedToParseHtml = true;\n                            }\n                        }\n                    }\n                    if (!failedToParseHtml) {\n                        html.push(node.textContent);\n                    }\n                }\n            }\n            alternative = alternative || node.contentType === 'multipart/alternative';\n            if (node.children) {\n                node.children.forEach(subNode => {\n                    processNode(alternative, level + 1, subNode);\n                });\n            }\n        };\n\n        processNode(false, 0, this.tree);\n\n        let response = {\n            type: 'text'\n        };\n        if (html.length) {\n            this.html = response.html = html.join('<br/>\\n');\n        }\n        if (text.length) {\n            this.text = response.text = text.join('\\n');\n            this.textAsHtml = response.textAsHtml = text.map(part => this.textToHtml(part)).join('<br/>\\n');\n        }\n        return response;\n    }\n\n    processChunk(data, done) {\n        let partId = null;\n        if (data._parentBoundary) {\n            partId = this._getPartId(data._parentBoundary);\n        }\n        switch (data.type) {\n            case 'node': {\n                let node = this.createNode(data);\n                if (node === this.tree) {\n                    ['subject', 'references', 'date', 'to', 'from', 'to', 'cc', 'bcc', 'message-id', 'in-reply-to', 'reply-to'].forEach(key => {\n                        if (node.headers.has(key)) {\n                            this[key.replace(/-([a-z])/g, (m, c) => c.toUpperCase())] = node.headers.get(key);\n                        }\n                    });\n                    this.emit('headers', node.headers);\n\n                    if (node.headerLines) {\n                        this.emit('headerLines', node.headerLines);\n                    }\n                }\n\n                if (data.contentType === 'message/rfc822' && data.messageNode) {\n                    break;\n                }\n\n                if (data.parentNode && data.parentNode.contentType === 'message/rfc822') {\n                    node.showMeta = true;\n                }\n\n                if (node.isAttachment) {\n                    let contentType = node.contentType;\n                    if (node.contentType === 'application/octet-stream' && data.filename) {\n                        contentType = this.libmime.detectMimeType(data.filename) || 'application/octet-stream';\n                    }\n\n                    let attachment = {\n                        type: 'attachment',\n                        content: null,\n                        contentType,\n                        partId,\n                        release: () => {\n                            attachment.release = null;\n                            if (this.waitUntilAttachmentEnd && typeof this.attachmentCallback === 'function') {\n                                setImmediate(this.attachmentCallback);\n                            }\n                            this.attachmentCallback = false;\n                            this.waitUntilAttachmentEnd = false;\n                        }\n                    };\n\n                    let algo = this.options.checksumAlgo || 'md5';\n                    let hasher = new StreamHash(attachment, algo);\n                    node.decoder.on('error', err => {\n                        hasher.emit('error', err);\n                    });\n\n                    node.decoder.on('readable', () => {\n                        let chunk;\n\n                        while ((chunk = node.decoder.read()) !== null) {\n                            hasher.write(chunk);\n                        }\n                    });\n\n                    node.decoder.once('end', () => {\n                        hasher.end();\n                    });\n\n                    //node.decoder.pipe(hasher);\n                    attachment.content = hasher;\n\n                    this.waitUntilAttachmentEnd = true;\n                    if (data.disposition) {\n                        attachment.contentDisposition = data.disposition;\n                    }\n\n                    if (data.filename) {\n                        attachment.filename = data.filename;\n                    }\n\n                    if (node.headers.has('content-id')) {\n                        attachment.contentId = [].concat(node.headers.get('content-id') || []).shift();\n                        attachment.cid = attachment.contentId.trim().replace(/^<|>$/g, '').trim();\n                        // check if the attachment is \"related\" to text content like an embedded image etc\n                        let parentNode = node;\n                        while ((parentNode = parentNode.parent)) {\n                            if (parentNode.contentType === 'multipart/related') {\n                                attachment.related = true;\n                            }\n                        }\n                    }\n\n                    attachment.headers = node.headers;\n                    this.push(attachment);\n                    this.attachmentList.push(attachment);\n                } else if (node.disposition === 'inline') {\n                    let chunks = [];\n                    let chunklen = 0;\n                    node.contentStream = node.decoder;\n\n                    if (node.contentType === 'text/plain') {\n                        this.hasText = true;\n                    } else if (node.contentType === 'text/html') {\n                        this.hasHtml = true;\n                    } else if (node.contentType === 'message/delivery-status' && !this.options.keepDeliveryStatus) {\n                        this.hasText = true;\n                    }\n\n                    if (node.node.flowed) {\n                        let contentStream = node.contentStream;\n                        let flowDecoder = new FlowedDecoder({\n                            delSp: node.node.delSp\n                        });\n                        contentStream.on('error', err => {\n                            flowDecoder.emit('error', err);\n                        });\n                        contentStream.pipe(flowDecoder);\n                        node.contentStream = flowDecoder;\n                    }\n\n                    let charset = node.charset || 'utf-8';\n                    //charset = charset || 'windows-1257';\n\n                    if (!['ascii', 'usascii', 'utf8'].includes(charset.toLowerCase().replace(/[^a-z0-9]+/g, ''))) {\n                        try {\n                            let contentStream = node.contentStream;\n                            let decodeStream = this.decoder.decodeStream(charset);\n                            contentStream.on('error', err => {\n                                decodeStream.emit('error', err);\n                            });\n                            contentStream.pipe(decodeStream);\n                            node.contentStream = decodeStream;\n                        } catch (E) {\n                            // do not decode charset\n                        }\n                    }\n\n                    node.contentStream.on('readable', () => {\n                        let chunk;\n                        while ((chunk = node.contentStream.read()) !== null) {\n                            if (typeof chunk === 'string') {\n                                chunk = Buffer.from(chunk);\n                            }\n                            chunks.push(chunk);\n                            chunklen += chunk.length;\n                        }\n                    });\n\n                    node.contentStream.once('end', () => {\n                        node.textContent = Buffer.concat(chunks, chunklen).toString().replace(/\\r?\\n/g, '\\n');\n                    });\n\n                    node.contentStream.once('error', err => {\n                        this.emit('error', err);\n                    });\n                }\n\n                break;\n            }\n\n            case 'data':\n                if (this.curnode && this.curnode.decoder) {\n                    this.curnode.decoder.end();\n                }\n\n                if (this.waitUntilAttachmentEnd) {\n                    this.attachmentCallback = done;\n                    return;\n                }\n\n                // multipart message structure\n                // this is not related to any specific 'node' block as it includes\n                // everything between the end of some node body and between the next header\n                //process.stdout.write(data.value);\n                break;\n\n            case 'body':\n                if (this.curnode && this.curnode.decoder && this.curnode.decoder.writable) {\n                    if (this.curnode.decoder.write(data.value) === false) {\n                        return this.curnode.decoder.once('drain', done);\n                    }\n                }\n\n                // Leaf element body. Includes the body for the last 'node' block. You might\n                // have several 'body' calls for a single 'node' block\n                //process.stdout.write(data.value);\n                break;\n        }\n\n        setImmediate(done);\n    }\n\n    _getPartId(parentBoundary) {\n        let boundaryIndex = this.boundaries.findIndex(item => item.name === parentBoundary);\n        if (boundaryIndex === -1) {\n            this.boundaries.push({ name: parentBoundary, count: 1 });\n            boundaryIndex = this.boundaries.length - 1;\n        } else {\n            this.boundaries[boundaryIndex].count++;\n        }\n        let partId = '1';\n        for (let i = 0; i <= boundaryIndex; i++) {\n            if (i === 0) partId = this.boundaries[i].count.toString();\n            else partId += '.' + this.boundaries[i].count.toString();\n        }\n        return partId;\n    }\n\n    getAddressesHTML(value) {\n        let formatSingleLevel = addresses =>\n            addresses\n                .map(address => {\n                    let str = '<span class=\"mp_address_group\">';\n                    if (address.name) {\n                        str += '<span class=\"mp_address_name\">' + he.encode(address.name) + (address.group ? ': ' : '') + '</span>';\n                    }\n                    if (address.address) {\n                        let link = '<a href=\"mailto:' + he.encode(address.address) + '\" class=\"mp_address_email\">' + he.encode(address.address) + '</a>';\n                        if (address.name) {\n                            str += ' &lt;' + link + '&gt;';\n                        } else {\n                            str += link;\n                        }\n                    }\n                    if (address.group) {\n                        str += formatSingleLevel(address.group) + ';';\n                    }\n                    return str + '</span>';\n                })\n                .join(', ');\n        return formatSingleLevel([].concat(value || []));\n    }\n\n    getAddressesText(value) {\n        let formatSingleLevel = addresses =>\n            addresses\n                .map(address => {\n                    let str = '';\n                    if (address.name) {\n                        str += `\"${address.name}\"` + (address.group ? ': ' : '');\n                    }\n                    if (address.address) {\n                        let link = address.address;\n                        if (address.name) {\n                            str += ' <' + link + '>';\n                        } else {\n                            str += link;\n                        }\n                    }\n                    if (address.group) {\n                        str += formatSingleLevel(address.group) + ';';\n                    }\n                    return str;\n                })\n                .join(', ');\n        return formatSingleLevel([].concat(value || []));\n    }\n\n    updateImageLinks(replaceCallback, done) {\n        if (!this.html) {\n            return setImmediate(() => done(null, false));\n        }\n\n        let cids = new Map();\n        let html = (this.html || '').toString();\n\n        if (this.options.skipImageLinks) {\n            return done(null, html);\n        }\n\n        html.replace(/\\bcid:([^'\"\\s]{1,256})/g, (match, cid) => {\n            for (let i = 0, len = this.attachmentList.length; i < len; i++) {\n                if (this.attachmentList[i].cid === cid && /^image\\/[\\w]+$/i.test(this.attachmentList[i].contentType)) {\n                    cids.set(cid, {\n                        attachment: this.attachmentList[i]\n                    });\n                    break;\n                }\n            }\n            return match;\n        });\n\n        let cidList = [];\n        cids.forEach(entry => {\n            cidList.push(entry);\n        });\n\n        let pos = 0;\n        let processNext = () => {\n            if (pos >= cidList.length) {\n                html = html.replace(/\\bcid:([^'\"\\s]{1,256})/g, (match, cid) => {\n                    if (cids.has(cid) && cids.get(cid).url) {\n                        return cids.get(cid).url;\n                    }\n                    return match;\n                });\n\n                return done(null, html);\n            }\n            let entry = cidList[pos++];\n            replaceCallback(entry.attachment, (err, url) => {\n                if (err) {\n                    return setImmediate(() => done(err));\n                }\n                entry.url = url;\n                setImmediate(processNext);\n            });\n        };\n\n        setImmediate(processNext);\n    }\n\n    textToHtml(str) {\n        if (this.options.skipTextToHtml) {\n            return '';\n        }\n        str = (str || '').toString();\n        let encoded;\n\n        let linkified = false;\n        if (!this.options.skipTextLinks) {\n            try {\n                if (linkify.pretest(str)) {\n                    linkified = true;\n                    let links = linkify.match(str) || [];\n                    let result = [];\n                    let last = 0;\n\n                    links.forEach(link => {\n                        if (last < link.index) {\n                            let textPart = he\n                                // encode special chars\n                                .encode(str.slice(last, link.index), {\n                                    useNamedReferences: true\n                                });\n                            result.push(textPart);\n                        }\n\n                        result.push(`<a href=\"${link.url}\">${link.text}</a>`);\n\n                        last = link.lastIndex;\n                    });\n\n                    let textPart = he\n                        // encode special chars\n                        .encode(str.slice(last), {\n                            useNamedReferences: true\n                        });\n                    result.push(textPart);\n\n                    encoded = result.join('');\n                }\n            } catch (E) {\n                // failed, don't linkify\n            }\n        }\n\n        if (!linkified) {\n            encoded = he\n                // encode special chars\n                .encode(str, {\n                    useNamedReferences: true\n                });\n        }\n\n        let text =\n            '<p>' +\n            encoded\n                .replace(/\\r?\\n/g, '\\n')\n                .trim() // normalize line endings\n                .replace(/[ \\t]+$/gm, '')\n                .trim() // trim empty line endings\n                .replace(/\\n\\n+/g, '</p><p>')\n                .trim() // insert <p> to multiple linebreaks\n                .replace(/\\n/g, '<br/>') + // insert <br> to single linebreaks\n            '</p>';\n\n        return text;\n    }\n}\n\nmodule.exports = MailParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9saWIvbWFpbC1wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsNEVBQW9CO0FBQzlDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLGdHQUE4QjtBQUM1RCxrQkFBa0IsdURBQTJCO0FBQzdDO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBYTtBQUN0QyxzQkFBc0IsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDckUsbUJBQW1CLG1CQUFPLENBQUMseUVBQWU7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLGdFQUFZO0FBQ2xDLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsNEVBQWM7QUFDN0MsV0FBVyxtQkFBTyxDQUFDLHlDQUFJO0FBQ3ZCLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFZO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyxrREFBTTtBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQyw4RUFBbUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFrRDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw2Q0FBNkMsMkJBQTJCO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNB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U0FBUyxJQUFJLFVBQVU7O0FBRXZFO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9seW1hcmtldC1hcmJpdHJhZ2Utbm9kZS8uL25vZGVfbW9kdWxlcy9tYWlscGFyc2VyL2xpYi9tYWlsLXBhcnNlci5qcz85NzA1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWFpbHNwbGl0ID0gcmVxdWlyZSgnQHpvbmUtZXUvbWFpbHNwbGl0Jyk7XG5jb25zdCBsaWJtaW1lID0gcmVxdWlyZSgnbGlibWltZScpO1xuY29uc3QgYWRkcmVzc3BhcnNlciA9IHJlcXVpcmUoJ25vZGVtYWlsZXIvbGliL2FkZHJlc3NwYXJzZXInKTtcbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbmNvbnN0IFNwbGl0dGVyID0gbWFpbHNwbGl0LlNwbGl0dGVyO1xuY29uc3QgQ2h1bmtlZFBhc3N0aHJvdWdoID0gbWFpbHNwbGl0LkNodW5rZWRQYXNzdGhyb3VnaDtcbmNvbnN0IHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUuanMnKTtcbmNvbnN0IEZsb3dlZERlY29kZXIgPSByZXF1aXJlKCdAem9uZS1ldS9tYWlsc3BsaXQvbGliL2Zsb3dlZC1kZWNvZGVyJyk7XG5jb25zdCBTdHJlYW1IYXNoID0gcmVxdWlyZSgnLi9zdHJlYW0taGFzaCcpO1xuY29uc3QgaWNvbnYgPSByZXF1aXJlKCdpY29udi1saXRlJyk7XG5jb25zdCB7IGh0bWxUb1RleHQgfSA9IHJlcXVpcmUoJ2h0bWwtdG8tdGV4dCcpO1xuY29uc3QgaGUgPSByZXF1aXJlKCdoZScpO1xuY29uc3QgbGlua2lmeSA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKSgpO1xuY29uc3QgdGxkcyA9IHJlcXVpcmUoJ3RsZHMnKTtcbmNvbnN0IGVuY29kaW5nSmFwYW5lc2UgPSByZXF1aXJlKCdlbmNvZGluZy1qYXBhbmVzZScpO1xuXG5saW5raWZ5XG4gICAgLnRsZHModGxkcykgLy8gUmVsb2FkIHdpdGggZnVsbCB0bGRzIGxpc3RcbiAgICAudGxkcygnb25pb24nLCB0cnVlKSAvLyBBZGQgdW5vZmZpY2lhbCBgLm9uaW9uYCBkb21haW5cbiAgICAuYWRkKCdnaXQ6JywgJ2h0dHA6JykgLy8gQWRkIGBnaXQ6YCBwdG90b2NvbCBhcyBcImFsaWFzXCJcbiAgICAuYWRkKCdmdHA6JywgbnVsbCkgLy8gRGlzYWJsZSBgZnRwOmAgcHRvdG9jb2xcbiAgICAuc2V0KHsgZnV6enlJUDogdHJ1ZSwgZnV6enlMaW5rOiB0cnVlLCBmdXp6eUVtYWlsOiB0cnVlIH0pO1xuXG4vLyB0d2l0dGVyIGxpbmtpZmllciBmcm9tXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdCNleGFtcGxlLTItYWRkLXR3aXR0ZXItbWVudGlvbnMtaGFuZGxlclxubGlua2lmeS5hZGQoJ0AnLCB7XG4gICAgdmFsaWRhdGUodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICAgIGxldCB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICAgIGlmICghc2VsZi5yZS50d2l0dGVyKSB7XG4gICAgICAgICAgICBzZWxmLnJlLnR3aXR0ZXIgPSBuZXcgUmVnRXhwKCdeKFthLXpBLVowLTlfXSl7MSwxNX0oPyFfKSg/PSR8JyArIHNlbGYucmUuc3JjX1pQQ2MgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnJlLnR3aXR0ZXIudGVzdCh0YWlsKSkge1xuICAgICAgICAgICAgLy8gTGlua2lmaWVyIGFsbG93cyBwdW5jdHVhdGlvbiBjaGFycyBiZWZvcmUgcHJlZml4LFxuICAgICAgICAgICAgLy8gYnV0IHdlIGFkZGl0aW9uYWxseSBkaXNhYmxlIGBAYCAoXCJAQG1lbnRpb25cIiBpcyBpbnZhbGlkKVxuICAgICAgICAgICAgaWYgKHBvcyA+PSAyICYmIHRhaWxbcG9zIC0gMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUudHdpdHRlcilbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgbm9ybWFsaXplKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLnVybCA9ICdodHRwczovL3R3aXR0ZXIuY29tLycgKyBtYXRjaC51cmwucmVwbGFjZSgvXkAvLCAnJyk7XG4gICAgfVxufSk7XG5cbmNsYXNzIEljb252RGVjb2RlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoSWNvbnYsIGNoYXJzZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBJY29udiB0aHJvd3MgZXJyb3Igb24ga3NfY181NjAxLTE5ODcgd2hlbiBpdCBpcyBtYXBwZWQgdG8gRVVDLUtSXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ibm9vcmRodWlzL25vZGUtaWNvbnYvaXNzdWVzLzE2OVxuICAgICAgICBpZiAoY2hhcnNldC50b0xvd2VyQ2FzZSgpID09PSAna3NfY181NjAxLTE5ODcnKSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gJ0NQOTQ5JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbSA9IG5ldyBJY29udihjaGFyc2V0LCAnVVRGLTgvL1RSQU5TTElULy9JR05PUkUnKTtcblxuICAgICAgICB0aGlzLmlucHV0RW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRDYiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgY2h1bmsgPT4gdGhpcy5wdXNoKGNodW5rKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmVuZENiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRDYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShjaHVuayk7XG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG5cbiAgICBfZmx1c2goZG9uZSkge1xuICAgICAgICB0aGlzLmVuZENiID0gZG9uZTtcbiAgICAgICAgdGhpcy5zdHJlYW0uZW5kKCk7XG4gICAgfVxufVxuXG5jbGFzcyBKUERlY29kZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJzZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rbGVuID0gMDtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHRoaXMuY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGRvbmUpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gQnVmZmVyLmNvbmNhdCh0aGlzLmNodW5rcywgdGhpcy5jaHVua2xlbik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gZW5jb2RpbmdKYXBhbmVzZS5jb252ZXJ0KGlucHV0LCB7XG4gICAgICAgICAgICAgICAgdG86ICdVTklDT0RFJywgLy8gdG9fZW5jb2RpbmdcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLmNoYXJzZXQsIC8vIGZyb21fZW5jb2RpbmdcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG91dHB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBCdWZmZXIuZnJvbShvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoKG91dHB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8ga2VlcCBhcyBpcyBvbiBlcnJvcnNcbiAgICAgICAgICAgIHRoaXMucHVzaChpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBkb25lKCk7XG4gICAgfVxufVxuXG5jbGFzcyBNYWlsUGFyc2VyIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcgfHwge307XG4gICAgICAgIHRoaXMuY2h1bmtlZFBhc3N0aHJvdWdoID0gbmV3IENodW5rZWRQYXNzdGhyb3VnaCgpO1xuICAgICAgICB0aGlzLnNwbGl0dGVyID0gbmV3IFNwbGl0dGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5jaHVua2VkUGFzc3Rocm91Z2gucGlwZSh0aGlzLnNwbGl0dGVyKTtcblxuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FpdGluZ0VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhlYWRlckxpbmVzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5lbmRSZWNlaXZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnRyZWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJub2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FpdFVudGlsQXR0YWNobWVudEVuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRDYWxsYmFjayA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaGFzSHRtbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1RleHQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnRleHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5odG1sID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dEFzSHRtbCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuYXR0YWNobWVudExpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLmJvdW5kYXJpZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnRleHRUeXBlcyA9IFsndGV4dC9wbGFpbicsICd0ZXh0L2h0bWwnXS5jb25jYXQoIXRoaXMub3B0aW9ucy5rZWVwRGVsaXZlcnlTdGF0dXMgPyAnbWVzc2FnZS9kZWxpdmVyeS1zdGF0dXMnIDogW10pO1xuXG4gICAgICAgIHRoaXMuZGVjb2RlciA9IHRoaXMuZ2V0RGVjb2RlcigpO1xuXG4gICAgICAgIHRoaXMuY2h1bmtlZFBhc3N0aHJvdWdoLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnNwbGl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zcGxpdHRlci5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkRGF0YSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNwbGl0dGVyLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTdHJlYW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zcGxpdHRlci5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndhaXRpbmdFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53YWl0aW5nRW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5saWJtaW1lID0gbmV3IGxpYm1pbWUuTGlibWltZSh7IEljb252OiB0aGlzLm9wdGlvbnMuSWNvbnYgfSk7XG4gICAgfVxuXG4gICAgZ2V0RGVjb2RlcigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5JY29udikge1xuICAgICAgICAgICAgY29uc3QgSWNvbnYgPSB0aGlzLm9wdGlvbnMuSWNvbnY7XG4gICAgICAgICAgICAvLyBjcmVhdGUgd3JhcHBlclxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVTdHJlYW0oY2hhcnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEljb252RGVjb2RlcihJY29udiwgY2hhcnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVjb2RlU3RyZWFtKGNoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9IChjaGFyc2V0IHx8ICdhc2NpaScpLnRvU3RyaW5nKCkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvXmppc3xeaXNvLT8yMDIyLT9qcHxeRVVDSlAvaS50ZXN0KGNoYXJzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugbm90IHN1cHBvcnRlZCBieSBpY29udi1saXRlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEpQRGVjb2RlcihjaGFyc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpY29udi5kZWNvZGVTdHJlYW0oY2hhcnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlYWREYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNGYWlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRpbmcgPSB0cnVlO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuc3BsaXR0ZXIucmVhZCgpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmRSZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kU3RyZWFtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb2Nlc3NDaHVuayhkYXRhLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy53YWl0aW5nRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRpbmdFbmQoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMucmVhZERhdGEoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVuZFN0cmVhbSgpIHtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuY3Vybm9kZSAmJiB0aGlzLmN1cm5vZGUuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlLmRlY29kZXIuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndhaXRpbmdFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ0VuZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICAgICAgaWYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtlZFBhc3N0aHJvdWdoLndyaXRlKGNodW5rKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rZWRQYXNzdGhyb3VnaC5vbmNlKCdkcmFpbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZmx1c2goZG9uZSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5jaHVua2VkUGFzc3Rocm91Z2guZW5kKCkpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xlYW51cChkb25lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhaXRpbmdFbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsZWFudXAoZG9uZSkge1xuICAgICAgICBsZXQgZmluaXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgdCA9IHRoaXMuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2godCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5jdXJub2RlICYmIHRoaXMuY3Vybm9kZS5kZWNvZGVyICYmIHRoaXMuY3Vybm9kZS5kZWNvZGVyLnJlYWRhYmxlICYmICF0aGlzLmRlY29kZXJFbmRlZCkge1xuICAgICAgICAgICAgKHRoaXMuY3Vybm9kZS5jb250ZW50U3RyZWFtIHx8IHRoaXMuY3Vybm9kZS5kZWNvZGVyKS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY3Vybm9kZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzc0hlYWRlcnMobGluZXMpIHtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIChsaW5lcyB8fCBbXSkuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgIGxldCBrZXkgPSBsaW5lLmtleTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICgodGhpcy5saWJtaW1lLmRlY29kZUhlYWRlcihsaW5lLmxpbmUpIHx8IHt9KS52YWx1ZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmluYXJ5JykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29udGVudC10eXBlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb250ZW50LWRpc3Bvc2l0aW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdka2ltLXNpZ25hdHVyZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5saWJtaW1lLnBhcnNlSGVhZGVyVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnZhbHVlID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cygodmFsdWUgJiYgdmFsdWUucGFyYW1zKSB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wYXJhbXNba2V5XSA9IHRoaXMubGlibWltZS5kZWNvZGVXb3Jkcyh2YWx1ZS5wYXJhbXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlLCBrZWVwIGFzIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0ZVZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGF0ZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0ZSBwYXJzaW5nIGZhaWxlZCA6U1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZVZhbHVlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N1YmplY3QnOlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmxpYm1pbWUuZGVjb2RlV29yZHModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUsIGtlZXAgYXMgaXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZWZlcmVuY2VzJzpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgvXFxzKy8pLm1hcCh0aGlzLmVuc3VyZU1lc3NhZ2VJREZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UtaWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2luLXJlcGx5LXRvJzpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmVuc3VyZU1lc3NhZ2VJREZvcm1hdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ByaW9yaXR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICd4LXByaW9yaXR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICd4LW1zbWFpbC1wcmlvcml0eSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wb3J0YW5jZSc6XG4gICAgICAgICAgICAgICAgICAgIGtleSA9ICdwcmlvcml0eSc7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVByaW9yaXR5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnJvbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NjJzpcbiAgICAgICAgICAgICAgICBjYXNlICdiY2MnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlbmRlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVwbHktdG8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGl2ZXJlZC10byc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuLXBhdGgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvbi10byc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYWRkcmVzc3BhcnNlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQWRkcmVzc2VzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHRoaXMuZ2V0QWRkcmVzc2VzSFRNTCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmdldEFkZHJlc3Nlc1RleHQodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGUgbGlzdC0qIGtleXNcbiAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyKDAsIDUpID09PSAnbGlzdC0nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlTGlzdEhlYWRlcihrZXkuc3Vic3RyKDUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAga2V5ID0gJ2xpc3QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoa2V5LCBbXS5jb25jYXQodmFsdWUgfHwgW10pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgaGVhZGVycy5nZXQoa2V5KS5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLmdldChrZXkpLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8ga2VlcCBvbmx5IHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICBsZXQgc2luZ2xlS2V5cyA9IFtcbiAgICAgICAgICAgICdtZXNzYWdlLWlkJyxcbiAgICAgICAgICAgICdjb250ZW50LWlkJyxcbiAgICAgICAgICAgICdmcm9tJyxcbiAgICAgICAgICAgICdzZW5kZXInLFxuICAgICAgICAgICAgJ2luLXJlcGx5LXRvJyxcbiAgICAgICAgICAgICdyZXBseS10bycsXG4gICAgICAgICAgICAnc3ViamVjdCcsXG4gICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAnY29udGVudC1kaXNwb3NpdGlvbicsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJyxcbiAgICAgICAgICAgICdjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nJyxcbiAgICAgICAgICAgICdwcmlvcml0eScsXG4gICAgICAgICAgICAnbWltZS12ZXJzaW9uJyxcbiAgICAgICAgICAgICdjb250ZW50LWRlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICdwcmVjZWRlbmNlJyxcbiAgICAgICAgICAgICdlcnJvcnMtdG8nLFxuICAgICAgICAgICAgJ2Rpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvbi10bydcbiAgICAgICAgXTtcblxuICAgICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVLZXlzLmluY2x1ZGVzKGtleSkgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWVbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIExpc3QtKiBoZWFkZXJzXG4gICAgICAgICAgICAgICAgbGV0IGxpc3RWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgIFtdLmNvbmNhdCh2YWx1ZSB8fCBbXSkuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWwgfHwge30pLmZvckVhY2gobGlzdEtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0VmFsdWVbbGlzdEtleV0gPSB2YWxbbGlzdEtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgbGlzdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgcGFyc2VMaXN0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGFkZHJlc3NlcyA9IGFkZHJlc3NwYXJzZXIodmFsdWUpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgbGV0IGRhdGEgPSBhZGRyZXNzZXNcbiAgICAgICAgICAgIC5tYXAoYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKC9eaHR0cHM/Oi9pLnRlc3QoYWRkcmVzcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS51cmwgPSBhZGRyZXNzLm5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhZGRyZXNzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubmFtZSA9IGFkZHJlc3MubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9ebWFpbHRvOi8udGVzdChhZGRyZXNzLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1haWwgPSBhZGRyZXNzLmFkZHJlc3Muc3Vic3RyKDcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5hZGRyZXNzICYmIGFkZHJlc3MuYWRkcmVzcy5pbmRleE9mKCdAJykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gYWRkcmVzcy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1haWwgPSBhZGRyZXNzLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXNwb25zZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoYWRkcmVzcyA9PiBhZGRyZXNzKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFtrZXldOiByZXNwb25zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGFyc2VQcmlvcml0eSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpKSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IFwiWC1Qcmlvcml0eTogMSAoSGlnaGVzdClcIlxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApIHx8IDA7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vcm1hbCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbG93JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdub24tdXJnZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICdsb3cnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2xvdyc7XG4gICAgICAgICAgICAgICAgY2FzZSAndXJnZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vcm1hbCc7XG4gICAgfVxuXG4gICAgZW5zdXJlTWVzc2FnZUlERm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApICE9PSAnPCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJzwnICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpICE9PSAnPicpIHtcbiAgICAgICAgICAgIHZhbHVlICs9ICc+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBkZWNvZGVBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgIGxldCBwcm9jZXNzZWRBZGRyZXNzID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gYWRkcmVzc2VzW2ldO1xuICAgICAgICAgICAgYWRkcmVzcy5uYW1lID0gKGFkZHJlc3MubmFtZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmICghYWRkcmVzcy5hZGRyZXNzICYmIC9eKD1cXD8oW14/XSspXFw/W0JiXVxcP1teP10qXFw/PSkoXFxzKj1cXD8oW14/XSspXFw/W0JiXVxcP1teP10qXFw/PSkqJC8udGVzdChhZGRyZXNzLm5hbWUpICYmICFwcm9jZXNzZWRBZGRyZXNzLmhhcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBhZGRyZXNzcGFyc2VyKHRoaXMubGlibWltZS5kZWNvZGVXb3JkcyhhZGRyZXNzLm5hbWUpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRBZGRyZXNzLmFkZChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MubmFtZSA9IHRoaXMubGlibWltZS5kZWNvZGVXb3JkcyhhZGRyZXNzLm5hbWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZ25vcmUsIGtlZXAgYXMgaXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL0B4bi0tLy50ZXN0KGFkZHJlc3MuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmFkZHJlc3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5hZGRyZXNzLnN1YnN0cigwLCBhZGRyZXNzLmFkZHJlc3MubGFzdEluZGV4T2YoJ0AnKSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1bnljb2RlLnRvVW5pY29kZShhZGRyZXNzLmFkZHJlc3Muc3Vic3RyKGFkZHJlc3MuYWRkcmVzcy5sYXN0SW5kZXhPZignQCcpICsgMSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdmFsaWQgcHVueWNvZGUgc3RyaW5nOyBrZWVwIGFzIGlzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUFkZHJlc3NlcyhhZGRyZXNzLmdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZU5vZGUobm9kZSkge1xuICAgICAgICBsZXQgY29udGVudFR5cGUgPSBub2RlLmNvbnRlbnRUeXBlO1xuICAgICAgICBsZXQgZGlzcG9zaXRpb24gPSBub2RlLmRpc3Bvc2l0aW9uO1xuICAgICAgICBsZXQgZW5jb2RpbmcgPSBub2RlLmVuY29kaW5nO1xuICAgICAgICBsZXQgY2hhcnNldCA9IG5vZGUuY2hhcnNldDtcblxuICAgICAgICBpZiAoIWNvbnRlbnRUeXBlICYmIG5vZGUucm9vdCkge1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSAndGV4dC9wbGFpbic7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBoZWFkZXJMaW5lczogbm9kZS5oZWFkZXJzLmxpbmVzLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5wcm9jZXNzSGVhZGVycyhub2RlLmhlYWRlcnMuZ2V0TGlzdCgpKSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCEvXm11bHRpcGFydFxcLy9pLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcG9zaXRpb24gJiYgIVsnYXR0YWNobWVudCcsICdpbmxpbmUnXS5pbmNsdWRlcyhkaXNwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NpdGlvbiA9ICdhdHRhY2htZW50JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkaXNwb3NpdGlvbiAmJiAhdGhpcy50ZXh0VHlwZXMuaW5jbHVkZXMoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5kaXNwb3NpdGlvbiA9ICdhdHRhY2htZW50JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5kaXNwb3NpdGlvbiA9IGRpc3Bvc2l0aW9uIHx8ICdpbmxpbmUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdOb2RlLmlzQXR0YWNobWVudCA9ICF0aGlzLnRleHRUeXBlcy5pbmNsdWRlcyhjb250ZW50VHlwZSkgfHwgbmV3Tm9kZS5kaXNwb3NpdGlvbiAhPT0gJ2lubGluZSc7XG5cbiAgICAgICAgICAgIG5ld05vZGUuZW5jb2RpbmcgPSBbJ3F1b3RlZC1wcmludGFibGUnLCAnYmFzZTY0J10uaW5jbHVkZXMoZW5jb2RpbmcpID8gZW5jb2RpbmcgOiAnYmluYXJ5JztcblxuICAgICAgICAgICAgaWYgKGNoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGVjb2RlciA9IG5vZGUuZ2V0RGVjb2RlcigpO1xuICAgICAgICAgICAgZGVjb2Rlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlckVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3Tm9kZS5kZWNvZGVyID0gZGVjb2RlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ld05vZGUuaGVhZGVycztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTGluZXMgPSBuZXdOb2RlLmhlYWRlckxpbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBsb2NhdGlvbiBpbiB0cmVlXG5cbiAgICAgICAgaWYgKCF0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgIG5ld05vZGUucm9vdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1cm5vZGUgPSB0aGlzLnRyZWUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbW1lZGlhdGUgY2hpbGQgb2Ygcm9vdCBub2RlXG4gICAgICAgIGlmICghdGhpcy5jdXJub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzLmN1cm5vZGU7XG4gICAgICAgICAgICB0aGlzLmN1cm5vZGUuY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuY3Vybm9kZSA9IG5ld05vZGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpYmxpbmdzXG4gICAgICAgIGlmICh0aGlzLmN1cm5vZGUucGFyZW50Lm5vZGUgPT09IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzLmN1cm5vZGUucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlLnBhcmVudC5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgY2hpbGRcbiAgICAgICAgaWYgKHRoaXMuY3Vybm9kZS5ub2RlID09PSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gdGhpcy5jdXJub2RlO1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLmN1cm5vZGUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHVwXG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy5jdXJub2RlO1xuICAgICAgICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLm5vZGUgPT09IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4sIGNhbid0IGRldGVjdCBwYXJlbnRcbiAgICAgICAgdGhpcy5jdXJub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuXG4gICAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gW107XG4gICAgICAgIGxldCBodG1sID0gW107XG4gICAgICAgIGxldCBwcm9jZXNzTm9kZSA9IChhbHRlcm5hdGl2ZSwgbGV2ZWwsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLnNob3dNZXRhKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ldGEgPSBbJ0Zyb20nLCAnU3ViamVjdCcsICdEYXRlJywgJ1RvJywgJ0NjJywgJ0JjYyddXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZmtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gZmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmhlYWRlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBub2RlLmhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGZrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihlbnRyeSA9PiBlbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzSHRtbCkge1xuICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwibXBfaGVhZFwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZW50cnkua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnRnJvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVG8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdCY2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmh0bWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMub3B0aW9ucy5mb3JtYXREYXRlU3RyaW5nID8gdGhpcy5vcHRpb25zLmZvcm1hdERhdGVTdHJpbmcodmFsdWUpIDogdmFsdWUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3ViamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJzxzdHJvbmc+JyArIGhlLmVuY29kZSh2YWx1ZSkgKyAnPC9zdHJvbmc+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBoZS5lbmNvZGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzx0cj48dGQgY2xhc3M9XCJtcF9oZWFkX2tleVwiPicgKyBoZS5lbmNvZGUoZW50cnkua2V5KSArICc6PC90ZD48dGQgY2xhc3M9XCJtcF9oZWFkX3ZhbHVlXCI+JyArIHZhbHVlICsgJzx0ZD48L3RyPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0YWJsZT4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZW50cnkua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnRnJvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVG8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdCY2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMub3B0aW9ucy5mb3JtYXREYXRlU3RyaW5nID8gdGhpcy5vcHRpb25zLmZvcm1hdERhdGVTdHJpbmcodmFsdWUpIDogdmFsdWUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkua2V5ICsgJzogJyArIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jb250ZW50VHlwZSA9PT0gJ3RleHQvcGxhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQucHVzaChub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHRlcm5hdGl2ZSAmJiB0aGlzLmhhc0h0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaCh0aGlzLnRleHRUb0h0bWwobm9kZS50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9kZWxpdmVyeS1zdGF0dXMnICYmICF0aGlzLm9wdGlvbnMua2VlcERlbGl2ZXJ5U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQucHVzaChub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHRlcm5hdGl2ZSAmJiB0aGlzLmhhc0h0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaCh0aGlzLnRleHRUb0h0bWwobm9kZS50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAndGV4dC9odG1sJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmFpbGVkVG9QYXJzZUh0bWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghYWx0ZXJuYXRpdmUgJiYgdGhpcy5oYXNUZXh0KSB8fCAobm9kZS5yb290ICYmICF0aGlzLmhhc1RleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBIdG1sVG9UZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50ZXh0Q29udGVudC5sZW5ndGggPiB0aGlzLm9wdGlvbnMubWF4SHRtbExlbmd0aFRvUGFyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGBIVE1MIHRvbyBsb25nIGZvciBwYXJzaW5nICR7bm9kZS50ZXh0Q29udGVudC5sZW5ndGh9IGJ5dGVzYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQucHVzaCgnSW52YWxpZCBIVE1MIGNvbnRlbnQgKHRvbyBsb25nKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxlZFRvUGFyc2VIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKGh0bWxUb1RleHQobm9kZS50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgSFRNTCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKCdJbnZhbGlkIEhUTUwgY29udGVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRUb1BhcnNlSHRtbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmFpbGVkVG9QYXJzZUh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaChub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsdGVybmF0aXZlID0gYWx0ZXJuYXRpdmUgfHwgbm9kZS5jb250ZW50VHlwZSA9PT0gJ211bHRpcGFydC9hbHRlcm5hdGl2ZSc7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChzdWJOb2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05vZGUoYWx0ZXJuYXRpdmUsIGxldmVsICsgMSwgc3ViTm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvY2Vzc05vZGUoZmFsc2UsIDAsIHRoaXMudHJlZSk7XG5cbiAgICAgICAgbGV0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChodG1sLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5odG1sID0gcmVzcG9uc2UuaHRtbCA9IGh0bWwuam9pbignPGJyLz5cXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlc3BvbnNlLnRleHQgPSB0ZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhpcy50ZXh0QXNIdG1sID0gcmVzcG9uc2UudGV4dEFzSHRtbCA9IHRleHQubWFwKHBhcnQgPT4gdGhpcy50ZXh0VG9IdG1sKHBhcnQpKS5qb2luKCc8YnIvPlxcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBwcm9jZXNzQ2h1bmsoZGF0YSwgZG9uZSkge1xuICAgICAgICBsZXQgcGFydElkID0gbnVsbDtcbiAgICAgICAgaWYgKGRhdGEuX3BhcmVudEJvdW5kYXJ5KSB7XG4gICAgICAgICAgICBwYXJ0SWQgPSB0aGlzLl9nZXRQYXJ0SWQoZGF0YS5fcGFyZW50Qm91bmRhcnkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdub2RlJzoge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5jcmVhdGVOb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgWydzdWJqZWN0JywgJ3JlZmVyZW5jZXMnLCAnZGF0ZScsICd0bycsICdmcm9tJywgJ3RvJywgJ2NjJywgJ2JjYycsICdtZXNzYWdlLWlkJywgJ2luLXJlcGx5LXRvJywgJ3JlcGx5LXRvJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVhZGVycy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5LnJlcGxhY2UoLy0oW2Etel0pL2csIChtLCBjKSA9PiBjLnRvVXBwZXJDYXNlKCkpXSA9IG5vZGUuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIG5vZGUuaGVhZGVycyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVhZGVyTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGVhZGVyTGluZXMnLCBub2RlLmhlYWRlckxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9yZmM4MjInICYmIGRhdGEubWVzc2FnZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGFyZW50Tm9kZSAmJiBkYXRhLnBhcmVudE5vZGUuY29udGVudFR5cGUgPT09ICdtZXNzYWdlL3JmYzgyMicpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zaG93TWV0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNBdHRhY2htZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IG5vZGUuY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyAmJiBkYXRhLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IHRoaXMubGlibWltZS5kZXRlY3RNaW1lVHlwZShkYXRhLmZpbGVuYW1lKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdHRhY2htZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F0dGFjaG1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQucmVsZWFzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMud2FpdFVudGlsQXR0YWNobWVudEVuZCAmJiB0eXBlb2YgdGhpcy5hdHRhY2htZW50Q2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKHRoaXMuYXR0YWNobWVudENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50Q2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRVbnRpbEF0dGFjaG1lbnRFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgYWxnbyA9IHRoaXMub3B0aW9ucy5jaGVja3N1bUFsZ28gfHwgJ21kNSc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNoZXIgPSBuZXcgU3RyZWFtSGFzaChhdHRhY2htZW50LCBhbGdvKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kZWNvZGVyLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmRlY29kZXIub24oJ3JlYWRhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNodW5rID0gbm9kZS5kZWNvZGVyLnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmRlY29kZXIub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaGVyLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvL25vZGUuZGVjb2Rlci5waXBlKGhhc2hlcik7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuY29udGVudCA9IGhhc2hlcjtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRVbnRpbEF0dGFjaG1lbnRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5kaXNwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jb250ZW50RGlzcG9zaXRpb24gPSBkYXRhLmRpc3Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuZmlsZW5hbWUgPSBkYXRhLmZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVhZGVycy5oYXMoJ2NvbnRlbnQtaWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jb250ZW50SWQgPSBbXS5jb25jYXQobm9kZS5oZWFkZXJzLmdldCgnY29udGVudC1pZCcpIHx8IFtdKS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jaWQgPSBhdHRhY2htZW50LmNvbnRlbnRJZC50cmltKCkucmVwbGFjZSgvXjx8PiQvZywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBhdHRhY2htZW50IGlzIFwicmVsYXRlZFwiIHRvIHRleHQgY29udGVudCBsaWtlIGFuIGVtYmVkZGVkIGltYWdlIGV0Y1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUuY29udGVudFR5cGUgPT09ICdtdWx0aXBhcnQvcmVsYXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5yZWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmhlYWRlcnMgPSBub2RlLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChhdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50TGlzdC5wdXNoKGF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5kaXNwb3NpdGlvbiA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2h1bmtsZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnRTdHJlYW0gPSBub2RlLmRlY29kZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudFR5cGUgPT09ICd0ZXh0L3BsYWluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAndGV4dC9odG1sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9kZWxpdmVyeS1zdGF0dXMnICYmICF0aGlzLm9wdGlvbnMua2VlcERlbGl2ZXJ5U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1RleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZS5mbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50U3RyZWFtID0gbm9kZS5jb250ZW50U3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsb3dEZWNvZGVyID0gbmV3IEZsb3dlZERlY29kZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbFNwOiBub2RlLm5vZGUuZGVsU3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb3dEZWNvZGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5waXBlKGZsb3dEZWNvZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudFN0cmVhbSA9IGZsb3dEZWNvZGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYXJzZXQgPSBub2RlLmNoYXJzZXQgfHwgJ3V0Zi04JztcbiAgICAgICAgICAgICAgICAgICAgLy9jaGFyc2V0ID0gY2hhcnNldCB8fCAnd2luZG93cy0xMjU3JztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIVsnYXNjaWknLCAndXNhc2NpaScsICd1dGY4J10uaW5jbHVkZXMoY2hhcnNldC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XSsvZywgJycpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFN0cmVhbSA9IG5vZGUuY29udGVudFN0cmVhbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVjb2RlU3RyZWFtID0gdGhpcy5kZWNvZGVyLmRlY29kZVN0cmVhbShjaGFyc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50U3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZVN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5waXBlKGRlY29kZVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50U3RyZWFtID0gZGVjb2RlU3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBkZWNvZGUgY2hhcnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50U3RyZWFtLm9uKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2h1bmsgPSBub2RlLmNvbnRlbnRTdHJlYW0ucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnRTdHJlYW0ub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBjaHVua2xlbikudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHI/XFxuL2csICdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50U3RyZWFtLm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vybm9kZSAmJiB0aGlzLmN1cm5vZGUuZGVjb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cm5vZGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy53YWl0VW50aWxBdHRhY2htZW50RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudENhbGxiYWNrID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG11bHRpcGFydCBtZXNzYWdlIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHJlbGF0ZWQgdG8gYW55IHNwZWNpZmljICdub2RlJyBibG9jayBhcyBpdCBpbmNsdWRlc1xuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgYmV0d2VlbiB0aGUgZW5kIG9mIHNvbWUgbm9kZSBib2R5IGFuZCBiZXR3ZWVuIHRoZSBuZXh0IGhlYWRlclxuICAgICAgICAgICAgICAgIC8vcHJvY2Vzcy5zdGRvdXQud3JpdGUoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cm5vZGUgJiYgdGhpcy5jdXJub2RlLmRlY29kZXIgJiYgdGhpcy5jdXJub2RlLmRlY29kZXIud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vybm9kZS5kZWNvZGVyLndyaXRlKGRhdGEudmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Vybm9kZS5kZWNvZGVyLm9uY2UoJ2RyYWluJywgZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMZWFmIGVsZW1lbnQgYm9keS4gSW5jbHVkZXMgdGhlIGJvZHkgZm9yIHRoZSBsYXN0ICdub2RlJyBibG9jay4gWW91IG1pZ2h0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBzZXZlcmFsICdib2R5JyBjYWxscyBmb3IgYSBzaW5nbGUgJ25vZGUnIGJsb2NrXG4gICAgICAgICAgICAgICAgLy9wcm9jZXNzLnN0ZG91dC53cml0ZShkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZShkb25lKTtcbiAgICB9XG5cbiAgICBfZ2V0UGFydElkKHBhcmVudEJvdW5kYXJ5KSB7XG4gICAgICAgIGxldCBib3VuZGFyeUluZGV4ID0gdGhpcy5ib3VuZGFyaWVzLmZpbmRJbmRleChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gcGFyZW50Qm91bmRhcnkpO1xuICAgICAgICBpZiAoYm91bmRhcnlJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRhcmllcy5wdXNoKHsgbmFtZTogcGFyZW50Qm91bmRhcnksIGNvdW50OiAxIH0pO1xuICAgICAgICAgICAgYm91bmRhcnlJbmRleCA9IHRoaXMuYm91bmRhcmllcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ib3VuZGFyaWVzW2JvdW5kYXJ5SW5kZXhdLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnRJZCA9ICcxJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYm91bmRhcnlJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgcGFydElkID0gdGhpcy5ib3VuZGFyaWVzW2ldLmNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBlbHNlIHBhcnRJZCArPSAnLicgKyB0aGlzLmJvdW5kYXJpZXNbaV0uY291bnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydElkO1xuICAgIH1cblxuICAgIGdldEFkZHJlc3Nlc0hUTUwodmFsdWUpIHtcbiAgICAgICAgbGV0IGZvcm1hdFNpbmdsZUxldmVsID0gYWRkcmVzc2VzID0+XG4gICAgICAgICAgICBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAubWFwKGFkZHJlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyID0gJzxzcGFuIGNsYXNzPVwibXBfYWRkcmVzc19ncm91cFwiPic7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnPHNwYW4gY2xhc3M9XCJtcF9hZGRyZXNzX25hbWVcIj4nICsgaGUuZW5jb2RlKGFkZHJlc3MubmFtZSkgKyAoYWRkcmVzcy5ncm91cCA/ICc6ICcgOiAnJykgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSAnPGEgaHJlZj1cIm1haWx0bzonICsgaGUuZW5jb2RlKGFkZHJlc3MuYWRkcmVzcykgKyAnXCIgY2xhc3M9XCJtcF9hZGRyZXNzX2VtYWlsXCI+JyArIGhlLmVuY29kZShhZGRyZXNzLmFkZHJlc3MpICsgJzwvYT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnICZsdDsnICsgbGluayArICcmZ3Q7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBmb3JtYXRTaW5nbGVMZXZlbChhZGRyZXNzLmdyb3VwKSArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXRTaW5nbGVMZXZlbChbXS5jb25jYXQodmFsdWUgfHwgW10pKTtcbiAgICB9XG5cbiAgICBnZXRBZGRyZXNzZXNUZXh0KHZhbHVlKSB7XG4gICAgICAgIGxldCBmb3JtYXRTaW5nbGVMZXZlbCA9IGFkZHJlc3NlcyA9PlxuICAgICAgICAgICAgYWRkcmVzc2VzXG4gICAgICAgICAgICAgICAgLm1hcChhZGRyZXNzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gYFwiJHthZGRyZXNzLm5hbWV9XCJgICsgKGFkZHJlc3MuZ3JvdXAgPyAnOiAnIDogJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5rID0gYWRkcmVzcy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnIDwnICsgbGluayArICc+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBmb3JtYXRTaW5nbGVMZXZlbChhZGRyZXNzLmdyb3VwKSArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXRTaW5nbGVMZXZlbChbXS5jb25jYXQodmFsdWUgfHwgW10pKTtcbiAgICB9XG5cbiAgICB1cGRhdGVJbWFnZUxpbmtzKHJlcGxhY2VDYWxsYmFjaywgZG9uZSkge1xuICAgICAgICBpZiAoIXRoaXMuaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBkb25lKG51bGwsIGZhbHNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2lkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGh0bWwgPSAodGhpcy5odG1sIHx8ICcnKS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcEltYWdlTGlua3MpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIGh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaHRtbC5yZXBsYWNlKC9cXGJjaWQ6KFteJ1wiXFxzXXsxLDI1Nn0pL2csIChtYXRjaCwgY2lkKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5hdHRhY2htZW50TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dGFjaG1lbnRMaXN0W2ldLmNpZCA9PT0gY2lkICYmIC9eaW1hZ2VcXC9bXFx3XSskL2kudGVzdCh0aGlzLmF0dGFjaG1lbnRMaXN0W2ldLmNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjaWRzLnNldChjaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQ6IHRoaXMuYXR0YWNobWVudExpc3RbaV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGNpZExpc3QgPSBbXTtcbiAgICAgICAgY2lkcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIGNpZExpc3QucHVzaChlbnRyeSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBsZXQgcHJvY2Vzc05leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocG9zID49IGNpZExpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXFxiY2lkOihbXidcIlxcc117MSwyNTZ9KS9nLCAobWF0Y2gsIGNpZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2lkcy5oYXMoY2lkKSAmJiBjaWRzLmdldChjaWQpLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNpZHMuZ2V0KGNpZCkudXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIGh0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVudHJ5ID0gY2lkTGlzdFtwb3MrK107XG4gICAgICAgICAgICByZXBsYWNlQ2FsbGJhY2soZW50cnkuYXR0YWNobWVudCwgKGVyciwgdXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGRvbmUoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudHJ5LnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUocHJvY2Vzc05leHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKHByb2Nlc3NOZXh0KTtcbiAgICB9XG5cbiAgICB0ZXh0VG9IdG1sKHN0cikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBUZXh0VG9IdG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGVuY29kZWQ7XG5cbiAgICAgICAgbGV0IGxpbmtpZmllZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5za2lwVGV4dExpbmtzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5raWZ5LnByZXRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5raWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlua3MgPSBsaW5raWZ5Lm1hdGNoKHN0cikgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA8IGxpbmsuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFBhcnQgPSBoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGUgc3BlY2lhbCBjaGFyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW5jb2RlKHN0ci5zbGljZShsYXN0LCBsaW5rLmluZGV4KSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlTmFtZWRSZWZlcmVuY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRleHRQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYDxhIGhyZWY9XCIke2xpbmsudXJsfVwiPiR7bGluay50ZXh0fTwvYT5gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGxpbmsubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFBhcnQgPSBoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIHNwZWNpYWwgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbmNvZGUoc3RyLnNsaWNlKGxhc3QpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlTmFtZWRSZWZlcmVuY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGV4dFBhcnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWQgPSByZXN1bHQuam9pbignJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgIC8vIGZhaWxlZCwgZG9uJ3QgbGlua2lmeVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5raWZpZWQpIHtcbiAgICAgICAgICAgIGVuY29kZWQgPSBoZVxuICAgICAgICAgICAgICAgIC8vIGVuY29kZSBzcGVjaWFsIGNoYXJzXG4gICAgICAgICAgICAgICAgLmVuY29kZShzdHIsIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlTmFtZWRSZWZlcmVuY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGV4dCA9XG4gICAgICAgICAgICAnPHA+JyArXG4gICAgICAgICAgICBlbmNvZGVkXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccj9cXG4vZywgJ1xcbicpXG4gICAgICAgICAgICAgICAgLnRyaW0oKSAvLyBub3JtYWxpemUgbGluZSBlbmRpbmdzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1sgXFx0XSskL2dtLCAnJylcbiAgICAgICAgICAgICAgICAudHJpbSgpIC8vIHRyaW0gZW1wdHkgbGluZSBlbmRpbmdzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcblxcbisvZywgJzwvcD48cD4nKVxuICAgICAgICAgICAgICAgIC50cmltKCkgLy8gaW5zZXJ0IDxwPiB0byBtdWx0aXBsZSBsaW5lYnJlYWtzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnPGJyLz4nKSArIC8vIGluc2VydCA8YnI+IHRvIHNpbmdsZSBsaW5lYnJlYWtzXG4gICAgICAgICAgICAnPC9wPic7XG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1haWxQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mailparser/lib/mail-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mailparser/lib/simple-parser.js":
/*!******************************************************!*\
  !*** ./node_modules/mailparser/lib/simple-parser.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MailParser = __webpack_require__(/*! ./mail-parser.js */ \"(rsc)/./node_modules/mailparser/lib/mail-parser.js\");\n\nmodule.exports = (input, options, callback) => {\n    if (input === null || input === undefined) {\n        throw new TypeError('Input cannot be null or undefined.');\n    }\n\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = false;\n    }\n\n    let promise;\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = callbackPromise(resolve, reject);\n        });\n    }\n\n    options = options || {};\n    let keepCidLinks = !!options.keepCidLinks;\n\n    let mail = {\n        attachments: []\n    };\n\n    let parser = new MailParser(options);\n\n    parser.on('error', err => {\n        callback(err);\n    });\n\n    parser.on('headers', headers => {\n        mail.headers = headers;\n        mail.headerLines = parser.headerLines;\n    });\n\n    let reading = false;\n    let reader = () => {\n        reading = true;\n\n        let data = parser.read();\n\n        if (data === null) {\n            reading = false;\n            return;\n        }\n\n        if (data.type === 'text') {\n            Object.keys(data).forEach(key => {\n                if (['text', 'html', 'textAsHtml'].includes(key)) {\n                    mail[key] = data[key];\n                }\n            });\n        }\n\n        if (data.type === 'attachment') {\n            mail.attachments.push(data);\n\n            let chunks = [];\n            let chunklen = 0;\n            data.content.on('readable', () => {\n                let chunk;\n                while ((chunk = data.content.read()) !== null) {\n                    chunks.push(chunk);\n                    chunklen += chunk.length;\n                }\n            });\n\n            data.content.on('end', () => {\n                data.content = Buffer.concat(chunks, chunklen);\n                data.release();\n                reader();\n            });\n        } else {\n            reader();\n        }\n    };\n\n    parser.on('readable', () => {\n        if (!reading) {\n            reader();\n        }\n    });\n\n    parser.on('end', () => {\n        ['subject', 'references', 'date', 'to', 'from', 'to', 'cc', 'bcc', 'message-id', 'in-reply-to', 'reply-to'].forEach(key => {\n            if (mail.headers && mail.headers.has(key)) {\n                mail[key.replace(/-([a-z])/g, (m, c) => c.toUpperCase())] = mail.headers.get(key);\n            }\n        });\n\n        if (keepCidLinks) {\n            return callback(null, mail);\n        }\n        parser.updateImageLinks(\n            (attachment, done) => done(false, 'data:' + attachment.contentType + ';base64,' + attachment.content.toString('base64')),\n            (err, html) => {\n                if (err) {\n                    return callback(err);\n                }\n                mail.html = html;\n\n                callback(null, mail);\n            }\n        );\n    });\n\n    if (typeof input === 'string') {\n        parser.end(Buffer.from(input));\n    } else if (Buffer.isBuffer(input)) {\n        parser.end(input);\n    } else {\n        input\n            .once('error', err => {\n                input.destroy();\n                parser.destroy();\n                callback(err);\n            })\n            .pipe(parser);\n    }\n\n    return promise;\n};\n\nfunction callbackPromise(resolve, reject) {\n    return function (...args) {\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9saWIvc2ltcGxlLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBa0I7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9seW1hcmtldC1hcmJpdHJhZ2Utbm9kZS8uL25vZGVfbW9kdWxlcy9tYWlscGFyc2VyL2xpYi9zaW1wbGUtcGFyc2VyLmpzPzBjMTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNYWlsUGFyc2VyID0gcmVxdWlyZSgnLi9tYWlsLXBhcnNlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrUHJvbWlzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQga2VlcENpZExpbmtzID0gISFvcHRpb25zLmtlZXBDaWRMaW5rcztcblxuICAgIGxldCBtYWlsID0ge1xuICAgICAgICBhdHRhY2htZW50czogW11cbiAgICB9O1xuXG4gICAgbGV0IHBhcnNlciA9IG5ldyBNYWlsUGFyc2VyKG9wdGlvbnMpO1xuXG4gICAgcGFyc2VyLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG5cbiAgICBwYXJzZXIub24oJ2hlYWRlcnMnLCBoZWFkZXJzID0+IHtcbiAgICAgICAgbWFpbC5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgbWFpbC5oZWFkZXJMaW5lcyA9IHBhcnNlci5oZWFkZXJMaW5lcztcbiAgICB9KTtcblxuICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IHJlYWRlciA9ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IHRydWU7XG5cbiAgICAgICAgbGV0IGRhdGEgPSBwYXJzZXIucmVhZCgpO1xuXG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoWyd0ZXh0JywgJ2h0bWwnLCAndGV4dEFzSHRtbCddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbFtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2F0dGFjaG1lbnQnKSB7XG4gICAgICAgICAgICBtYWlsLmF0dGFjaG1lbnRzLnB1c2goZGF0YSk7XG5cbiAgICAgICAgICAgIGxldCBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIGxldCBjaHVua2xlbiA9IDA7XG4gICAgICAgICAgICBkYXRhLmNvbnRlbnQub24oJ3JlYWRhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGNodW5rID0gZGF0YS5jb250ZW50LnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBjaHVua2xlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGEuY29udGVudC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRhdGEuY29udGVudCA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBjaHVua2xlbik7XG4gICAgICAgICAgICAgICAgZGF0YS5yZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgcmVhZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWRlcigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHBhcnNlci5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgIGlmICghcmVhZGluZykge1xuICAgICAgICAgICAgcmVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHBhcnNlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBbJ3N1YmplY3QnLCAncmVmZXJlbmNlcycsICdkYXRlJywgJ3RvJywgJ2Zyb20nLCAndG8nLCAnY2MnLCAnYmNjJywgJ21lc3NhZ2UtaWQnLCAnaW4tcmVwbHktdG8nLCAncmVwbHktdG8nXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAobWFpbC5oZWFkZXJzICYmIG1haWwuaGVhZGVycy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1haWxba2V5LnJlcGxhY2UoLy0oW2Etel0pL2csIChtLCBjKSA9PiBjLnRvVXBwZXJDYXNlKCkpXSA9IG1haWwuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGtlZXBDaWRMaW5rcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG1haWwpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci51cGRhdGVJbWFnZUxpbmtzKFxuICAgICAgICAgICAgKGF0dGFjaG1lbnQsIGRvbmUpID0+IGRvbmUoZmFsc2UsICdkYXRhOicgKyBhdHRhY2htZW50LmNvbnRlbnRUeXBlICsgJztiYXNlNjQsJyArIGF0dGFjaG1lbnQuY29udGVudC50b1N0cmluZygnYmFzZTY0JykpLFxuICAgICAgICAgICAgKGVyciwgaHRtbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1haWwuaHRtbCA9IGh0bWw7XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnNlci5lbmQoQnVmZmVyLmZyb20oaW5wdXQpKTtcbiAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcGFyc2VyLmVuZChpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRcbiAgICAgICAgICAgIC5vbmNlKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZShwYXJzZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufTtcblxuZnVuY3Rpb24gY2FsbGJhY2tQcm9taXNlKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBsZXQgZXJyID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mailparser/lib/simple-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mailparser/lib/stream-hash.js":
/*!****************************************************!*\
  !*** ./node_modules/mailparser/lib/stream-hash.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\n\nclass StreamHash extends Transform {\n    constructor(attachment, algo) {\n        super();\n        this.attachment = attachment;\n        this.algo = (algo || 'md5').toLowerCase();\n        this.hash = crypto.createHash(algo);\n        this.byteCount = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        this.hash.update(chunk);\n        this.byteCount += chunk.length;\n        done(null, chunk);\n    }\n\n    _flush(done) {\n        this.attachment.checksum = this.hash.digest('hex');\n        this.attachment.size = this.byteCount;\n        done();\n    }\n}\n\nmodule.exports = StreamHash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9saWIvc3RyZWFtLWhhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGtCQUFrQix1REFBMkI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2x5bWFya2V0LWFyYml0cmFnZS1ub2RlLy4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbGliL3N0cmVhbS1oYXNoLmpzPzFiODIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcblxuY2xhc3MgU3RyZWFtSGFzaCBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoYXR0YWNobWVudCwgYWxnbykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuICAgICAgICB0aGlzLmFsZ28gPSAoYWxnbyB8fCAnbWQ1JykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5oYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnbyk7XG4gICAgICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICB0aGlzLmhhc2gudXBkYXRlKGNodW5rKTtcbiAgICAgICAgdGhpcy5ieXRlQ291bnQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBkb25lKG51bGwsIGNodW5rKTtcbiAgICB9XG5cbiAgICBfZmx1c2goZG9uZSkge1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnQuY2hlY2tzdW0gPSB0aGlzLmhhc2guZGlnZXN0KCdoZXgnKTtcbiAgICAgICAgdGhpcy5hdHRhY2htZW50LnNpemUgPSB0aGlzLmJ5dGVDb3VudDtcbiAgICAgICAgZG9uZSgpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1IYXNoO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mailparser/lib/stream-hash.js\n");

/***/ })

};
;